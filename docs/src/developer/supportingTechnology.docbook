<!--
  Chapter covering supporting technology in the DrJava Developer 
  Documentation.  All chapters are joined into a single document 
  in devdoc.docbook.
  
  @version $Id: devdoc.docbook 3498 2006-01-17 22:36:31Z dlsmith $
-->

<chapter id="supportingTechnology">
  <title>Supporting Technology</title>
  <para>This section is intended as a repository of acquired knowledge with respect to supporting technology used with DrJava.  For each tool or library, a section will address questions like:
  
    <itemizedlist>
      <listitem><para>How is this technology used in the DrJava code base or build process?</para></listitem>
      
      <listitem><para>How is the technology distributed; what needs to be done to install it?</para></listitem>
      
      <listitem><para>Do we depend on a specific version of the software?</para></listitem>
      
      <listitem><para>What are the key options or classes that developers should be aware of?</para></listitem>
      
      <listitem><para>Where can more comprehensive documentation be found?</para></listitem>

      <listitem><para>Why has this particular technology been chosen?  What are the alternatives?</para></listitem>
      
    </itemizedlist>
  </para>

  <section id="java">
    <title>Java Language & APIs</title>
    <para>The Java language and APIs are documented by Sun at <ulink url="http://java.sun.com">http://java.sun.com</ulink>.  The language actually exists in different "editions": Standard Edition (SE), Enterprise Edition (EE), and a collection of Micro Editions (ME).  The Standard Edition is DrJava's target platform.  See the <link linkend="installJDK">JDK section of Getting Started</link> for instruction on installing Java.</para>
    <para>The language itself is documented by the Java Language Specification, available at <ulink url="http://java.sun.com/docs/books/jls/index.html">http://java.sun.com/docs/books/jls</ulink>.  This is a good authoritative reference on the language, and any good Java developer should be familiar with it.</para>
    <section>
      <title>The <command>java</command> Command</title>
      <para>Java sources are compiled to a collection of <literal>class</literal> files.  These files can then be interpreted by a Java interpreter, which creates a <firstterm>Java virtual machine (JVM)</firstterm> and executes a class's <literal>main</literal> method.  Sun's <command>java</command> is one such interpreter.</para>
      <para>Documentation on the <command>java</command> command can be found with <ulink url="http://java.sun.com/j2se/1.5.0/docs/tooldocs/">Sun's Java tools documentation</ulink>.</para>
      <para>A typical invocation of the interpreter looks like this:
        <informalexample><para><literal>java -cp lib/plt.jar:classes/base edu.rice.cs.MyClass</literal></para></informalexample>
        The <literal>-cp</literal> option specifies a <firstterm>class path</firstterm> &mdash; a collection of files or directories in which the necessary <literal>class</literal> files are located.  This path is searched from left to right; when the code makes reference to an unknown class name, the first matching <literal>class</literal> file on the class path is used.</para>
      <para>Directories of <literal>class</literal> files may be packaged and compressed into a single <literal>jar</literal> file for simplified distribution.  These are essentially just <literal>zip</literal> archives of <literal>class</literal> file collections.  In addition, a default <literal>main</literal> class can be specified for a <literal>jar</literal> file.  Since all necessary classes for running DrJava are bundled into a single <literal>jar</literal> file, this allows the application to be run with a simplified command syntax: 
        <informalexample><para><literal>java -jar drjava.jar</literal></para></informalexample>
      </para>
    </section>
    <section>
      <title>Standard Java APIs</title>
      <para>DrJava is written in version 5 of Java, and makes extensive use of features that are new in that version.  It's especially important that DrJava developers be quite comfortable with Java generics.  Sun has posted a <ulink url="http://java.sun.com/j2se/1.5/pdf/generics-tutorial.pdf">tutorial by Gilad Bracha</ulink> that provides a good overview.  There is also a a good <ulink url="http://java.sun.com/j2se/1.5.0/docs/guide/language/index.html">summary of Java 5 features</ulink> available in Sun's documentation.</para>
      <para>The API specification is another essential reference for developers, available here: <ulink url="http://java.sun.com/j2se/1.5.0/docs/api/">http://java.sun.com/j2se/1.5.0/docs/api/</ulink>.  A few important packages in the API include:
        <variablelist>
          <varlistentry>
            <term><literal>java.lang</literal></term>
            <listitem><para>The <literal>Object</literal> class, wrapper classes, strings, threads, and interface with the system are all defined here.</para></listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>java.util</literal></term>
            <listitem><para>Standard lists, maps, and other collections are defined here.  Note that the newer, non-synchronized classes (like <literal>ArrayList</literal>) are usually preferred over their older, synchronized counterparts (like <literal>Vector</literal>).</para></listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>java.io</literal></term>
            <listitem><para>Provides access to file reading and writing and other file-system operations.</para></listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>javax.swing</literal></term>
            <listitem><para>The DrJava GUI is implemented using <firstterm>Swing</firstterm>, the standard Java GUI framework.  (Note that many Swing classes and concepts depend on the <literal>java.awt</literal> package.)</para></listitem>
          </varlistentry>
        </variablelist>
      </para>

      <para>The <ulink url="http://java.sun.com/docs/books/tutorial/">Java Tutorial</ulink> provides a collection of small tutorials covering different parts of the APIs.</para>

      <para>Development in DrJava is limited in some ways by a desire for backwards compatibility.  While the program is developed using Java 5, it is still released for platforms that only support Java 1.4.  Thus, most classes and methods that were introduced with the Java 5 APIs cannot currently be used in DrJava.  (Such classes and methods should be designated with a "since 1.5" tag in the API documentation.)  For details, see the discussion on <link linkend="retroweaver">Retroweaver</link>, a tool that enables this backwards compatibility.</para>
    </section>
  </section>

  <section id="javac">
    <title><command>javac</command></title>
    <para>The Sun Java compiler, <command>javac</command>, is used to build DrJava.  The DrJava application also interfaces, at runtime, with the user's <command>javac</command> compiler.  See the <link linkend="installJDK">JDK section of Getting Started</link> for installation instructions.</para>
    <para>Documentation on the <command>javac</command> command can be found with <ulink url="http://java.sun.com/j2se/1.5.0/docs/tooldocs/">Sun's Java tools documentation</ulink>.</para>
    <section>
      <title>Compilation Paths</title>
      <para>There are a number of search paths used as parameters to perform compilation.  To avoid confusion, it's important to be familiar with the distinction between them.
      <itemizedlist>
        <listitem><para>The <firstterm>boot class path</firstterm> is the location of the standard Java APIs.  It is conceptually prepended to the standard class path whenever a search for a class occurs.  By default, this is the location of the APIs used to run the compiler; it is only necessary to manipulate this setting if compilation should occur against a different or customized version of the APIs.</para></listitem>
        <listitem><para>The <firstterm>class path</firstterm> points to additional libraries and classes used for compilation.  For example, if JUnit tests are to be compiled, the <filename>junit.jar</filename> file should be on the class path.  If iterative updates are to be made to the sources (as is usually the case), the location of the compiled classes should be part of the class path as well.</para></listitem>
        <listitem><para>The <firstterm>source path</firstterm> is the location of source files that, while not explicitly required to be compiled, can be automatically compiled if the classes they define are needed.  This allows, for example, the compilation of a single source file to silently trigger the compilation of many others.  Since such on-demand processing changes the compiler's internal symbol tables on-the-fly, however, it's generally not a good idea to take advantage of this feature &mdash; changing the order in which sources are passed to the compiler can change the meaning of the program!  A better alternative is to simply list <emphasis>all</emphasis> sources that need to be compiled explicitly (Ant and DrJava do this easily and automatically), and set the source path to an empty string.</para></listitem>
        <listitem><para>The <firstterm>compiler JVM boot class path</firstterm> is the location of the Java APIs used to <emphasis>run</emphasis> the compiler.  Since <command>javac</command> is <emphasis>implemented</emphasis> in Java, it runs in a JVM, and that JVM needs access to the standard APIs.  It's important to note that there need not be any relationship between this value and tha compilation boot class path.  The <command>javac</command> command should automatically set up this parameter correctly.</para></listitem>
        <listitem><para>Similarly, the <firstterm>compiler JVM class path</firstterm> is the location of additional libraries and classes used to <emphasis>run</emphasis> the compiler.  Typically, the classes implementing the compiler are found in a <filename>tools.jar</filename> file, and that jar file will need to be on the compiler JVM class path.  Again, there need not be any relationship between this value and the compilation class path.  And the <command>javac</command> command will automatically set this correctly.</para></listitem>
      </itemizedlist></para>
    </section>
      
  </section>
  
  <section id="javadoc">
    <title><command>javadoc</command></title>
    <para>[TODO]</para>
    <!-- We can point to the <link linkend="installJDK">JDK installation instructions</link> for installation details -->
  </section>
  
  <section id="rmi">
    <title>RMI</title>
    <para>[TODO]</para>
    <!-- We can point to the <link linkend="installJDK">JDK installation instructions</link> for installation details -->
  </section>
  
  <section id="jpda">
    <title>JPDA</title>
    <para>[TODO]</para>
    <!-- We can point to the <link linkend="installJDK">JDK installation instructions</link> for installation details -->
  </section>
  
  <section id="subversion">
    <title>Subversion</title>
    <para>[TODO]</para>
    <!-- We can point to the <link linkend="installSubversion">Subversion installation instructions</link> for installation details -->
    <!-- Should include instructions on moving and adding files, and on tagging and branching -->
    <!-- Clipped from the previous docs:
              <para>If you will be adding new files as part of your commit, you will need to first let the CVS server know that the new files exist.  Run "<literal>cvs add [FILE]</literal>" for each new file that you will be adding before running <literal>ant commit</literal>.  Also, it is very important that you copy the license comment from another file into your new file.  We also prefer that you include a "<literal>@version &#36;Id&#36;</literal>" tag in your class-level Javadoc comment, which helps us note the last time the file was modified.</para>
-->
  </section>
  
  <section id="ant">
    <title>Ant</title>
    <para>[TODO]</para>
    <!-- We can point to the <link linkend="installAnt">Ant installation instructions</link> for installation details -->
  </section>
  
  <section id="junit">
    <title>JUnit</title>
    <para>[TODO]</para>
    <!-- We can point to the <link linkend="installJUnit">JUnit installation instructions</link> for installation details -->
  </section>
  
  <section id="SourceForge">
    <title>SourceForge</title>
    <para>[TODO]</para>
  </section>
  
  <section id="clover">
    <title>Clover</title>
    <para>[TODO]</para>
  </section>
  
  <section id="retroweaver">
    <title>Retroweaver</title>
    <para>[TODO]</para>
  </section>
  
  <section id="docbook">
    <title>DocBook</title>
    <para>[TODO]</para>
    <!-- Clipped from the previous docs:
    Beware that some versions of these tools may not work with our build script or may generate HTML files without an <filename>index.html</filename> file.  (If this is the case, as it is currently on the greenland server, you'll probably want to copy <filename>book1.html</filename> to <filename>index.html</filename>.  Don't just rename it, because other files will link to the old one.)
    -->
  </section>
  
  <section id="javacc">
    <title>JavaCC</title>
    <para>[TODO]</para>
  </section>
  
  <section id="bcel">
    <title>BCEL</title>
    <para>[TODO]</para>
  </section>
 
  <section id="yourKit">
    <title>YourKit Java Profiler</title>
    <subtitle>(compiled by Mathias Ricken, mgricken at rice dot edu)</subtitle>
    <para>The  <ulink url="http://www.yourkit.com/download/">YourKit Java Profiler</ulink> is a powerful profiler
	for Java programs that has been lincensed to the DrJava open source project free of charge. It may only be
	used for developing and improving DrJava and individual licenses for each individual developer are
	required; they also need to be renewed from time to time. All of this has been generally unproblematic by
	emailing <ulink url="mailto://sales@yourkit.com">sales@yourkit.com</ulink>. Please do not jeopardize our
	very good relationshit with YourKit by using it in ways not approved.</para>
    <para>
       <orderedList>
          <listitem>
            <formalpara>
              <title><literal>Getting YourKit</literal></title>
              <para>You can download YourKit from the URL above, but have also installed YourKit into
		the javaplt account on CSnet. Here are instructions if you want to use it. Please note that this
		is for the Linux environment on CSnet. For Windows and MacOS, or away from CSnet, these steps
		don't apply.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title><literal>Location of YourKit on CSnet</literal></title>
              <para>YourKit is located in the directory <literal>/home/javaplt/packages/yjp-6.0.11</literal> .   You
		should add the <literal>bin</literal> path to your <literal>PATH</literal> environment
		variable. Make the following directory accessible from everywhere:
		<literal>/home/javaplt/packages/yjp-6.0.11/bin</literal>    .
              	That gives you access to the two most important scripts, <literal>yjp.sh</literal> and
		<literal>yjpjava</literal>   .</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
	      <title><literal>Adding the Library</literal></title>
              <para>Before you can use Yourkit, you have to set the following environment variable:   
              <literal>setenv LD_LIBRARY_PATH /home/javaplt/packages/yjp-6.0.11/bin/linux-x86-32</literal>       .
	      If you already have an <literal>LD_LIBRARY_PATH</literal>    variable, then you
		should extend it by adding a colon and the path:   
	      <literal>setenv LD_LIBRARY_PATH $LD_LIBRARY_PATH:/home/javaplt/packages/yjp-6.0.11/bin/linux-x86-32</literal>           .</para>
            </formalpara>
	  </listitem>
	  <listitem>
            <formalpara>
              <title><literal>Starting YourKit</literal</title>
              <para>To start YourKit, run the following script from the command line:     
                         <literal>yjp.sh &              </literal>.            
              The & at the end will make YourKit run in the background, i.e. you can
                still use the same command line window you've been using.
              The first time you start YourKit, it should ask you for your license
		information. If you are a member of the core DrJava development team, you
		should have by now received your personalized license key.</para>
            </formalpara>
          </listitem>
	  <listitem>
            <formalpara>
              <title><literal>Starting the Application to Profile</literal></title>
              <para>You need to pass a special command line argument to your java
		executable when you're running a program that you want to profile:          
	      <literal>-agentlib:yjpagent</literal>              .
              To make that easier to remember, I have written a script that passes
		that arguments, and all the argument passed to the script, to java.
		It's located in the same directory as Yourkit:                
	      <literal>/home/javaplt/packages/yjp-6.0.11/bin/yjpjava             </literal>          .
              If you added YourKit to your path in step 2, it should be directly
		accessible.
	      If you want to use it to run a program that you would normally start
		with:             
	      <literal>java MyClass                  </literal>            .
	      now just use:                   
	      <literal>yjpjava MyClass                </literal>           .
	      Here is a more complicated example to start DrJava. Instead of
		writing:              
	      <literal>java -cp drjava-15.jar edu.rice.cs.drjava.DrJava                 </literal>           .
	      now write instead the following, which avoids the restart, which may cause
		trouble:            
	      <literal>yjpjava -cp drjava-15.jar edu.rice.cs.drjava.DrJavaRoot             </literal>          .
	      Regardless, the application you just started should launch now.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title><literal>Starting to Profile</literal></title>
              <para>When you actually want to record usage times and counts, press the
		"Start CPU Profiling" button. That will open another pane. There are
		two selections, "Sampling" and "Tracing", and as far as I know,
		"Sampling" records times only and doesn't give you invocation counts
		and call stacks, but is faster. "Tracing" is a lot slower but gives
		you more information.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title><literal>Viewing Data</literal></title>
              <para>When you want to view the data, i.e. when you're done performing
		the action you want to profile, press the "Capture Snapshot" button.
		That will bring up a dialog that tells you the file name as which the
		snapshot has been saved, and it asks you whether you want to open the
		snapshot. You probably want to press "Open" if you want to look at the
		data right now.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title><literal>Taking a Snapshot Stops Profiling</literal></title>
              <para>Note that taking a snapshot stops profiling, so if you want to
		continue to profile, you need to press the "Start CPU Profiling"
		button again.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title><literal>Sorting Methods</literal></title>
              <para>On the page that displays CPU snapshot informations, there are lots
		of ways to gather information. I haven't explored everything. I found
		selecting "Method List" on the left the most useful. That will give
		you a lsit of all methods that were called, and you can sort by name,
		time, own time, and invocation count (if you used tracing). Time
		includes time spent in calls to other methods, i.e. the time from
		method entry to method exit. Own time is only the time spent in the
		actual method, i.e. the time from method entry to method exit
		EXCLUDING the time spent in other methods that were called.</para>
            </formalpara>
          </listitem>
          <listitem>
            <formalpara>
              <title><literal>Finding the Hotspot</literal></title>
              <para>Usually I found a very sharp break between the times, i.e. going from
		40 seconds in some methods (that were probably in a call chain) to 5
		seconds. My intuition tells me that the last method to have a lot of
		time spent is one of the "hot spots". You should also look at the
		invocation count: The program may spend a lot of time in a method, but
		if it's called very often, that may not mean very much.</para>
            </formalpara>
          </listitem>
       </orderedList>
    </para>
  </section>  

  <section id="otherTools">
    <title>Other Useful Development Tools</title>
    <para>[TODO]</para>
    
    <section id="findbugs">
      <title>FindBugs</title>
      <para>[TODO]</para>
    </section>
  
    <section id="x11">
      <title>X11</title>
      <para>[TODO]</para>
      <!-- This can contain tips and guidance on building remotely using X11 -->
      <!-- Clipped from the previous docs:
        <para>If you are running the tests on Windows over an SSH connection to a Unix server, you will need to have an X server running (such as X-Win32), and you will need to enable "X11 Tunneling" in the preferences of your SSH client.  This is because Swing components will be created in the tests, which require an X server even if they are not explicitly shown.</para>
        -->

    </section>

    <section id="eclipse">
      <title>Eclipse</title>
      <para>[TODO]</para>
      <!-- This can contain tips on how to use some of Eclipse's features - how to use it as the IDE, taking advantage of its extensive compiler warnings, etc. -->
    </section>
    
  </section>
  
</chapter>

