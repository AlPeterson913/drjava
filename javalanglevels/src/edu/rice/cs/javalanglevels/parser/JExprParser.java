/* JExprParser.java */
/* Generated By:JavaCC: Do not edit this line. JExprParser.java */
package edu.rice.cs.javalanglevels.parser;

import java.io.File;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.util.ListIterator;
import java.util.LinkedList;
import java.util.Vector;
import java.math.BigInteger;

//import edu.rice.cs.javaast.*;
//import edu.rice.cs.javaast.Visibility;
//import edu.rice.cs.javaast.ClassModifier;
//import edu.rice.cs.javaast.SourceInfo;
//import edu.rice.cs.javaast.CharConverter;
import edu.rice.cs.javalanglevels.*;
import edu.rice.cs.javalanglevels.tree.*;

public class JExprParser implements JExprParserConstants {

  public static final ClassOrInterfaceType NO_TYPE = new ClassOrInterfaceType(SourceInfo.NO_INFO, "Object", new Type[0]);
  private boolean _inInterface;

//  private Vector<ParseException> _errors;
  private static File _currentFile;
  public static void main(String args[]) {
    JExprParser parser;
      //    _errors = new Vector<ParseException>();
      if (args.length == 0) {
        System.out.println("JExpression Parser Version 1.0.3:  Reading from standard input . . .");
        parser = new JExprParser(System.in);
      }
      else if (args.length == 1) {
        System.out.println("JExpression Parser Version 1.0.3:  Reading from file " + args[0] + " . . .");
        try {
          _currentFile = new File(args[0]);
          parser = new JExprParser(new java.io.FileInputStream(_currentFile));
        } catch (java.io.FileNotFoundException e) {
          System.out.println("JExpression Parser Version 1.0.3:  File " + args[0] + " not found.");
          return;
        }
      }
      else {
        System.out.println("JExpression Parser Version 1.0.3:  Usage is one of:");
        System.out.println("         java JavaParser < inputfile");
        System.out.println("OR");
        System.out.println("         java JavaParser inputfile");
        return;
      }

      try {
        SourceFile result = parser.SourceFile();
        System.out.println("JExpression Parser Version 1.0.3:  Java program parsed successfully.");
        System.out.println(result.toString());
      }
      catch (Exception e) {
          System.out.println("JExpression Parser Version 1.0.3:  Encountered errors during parse.");
          System.out.println(e.toString());
      }
  }

  public JExprParser(File file) throws FileNotFoundException {
    this(new BufferedReader(new FileReader(file)));
    _currentFile = file;
  }

  /** Strips off the "l" or "L" off the end of long literals. */
  private static String _stripL(String in) {
    if (in.endsWith("l") || in.endsWith("L")) {
      return in.substring(0, in.length() - 1);
    }
    else {
      return in;
    }
  }

  /** Returns in without first and last character. */
  private static String _stripQuotes(String in) {
    int len = in.length();

    return in.substring(1, len - 1);
  }

  /** Creates a source location that starts at the given first token and ends in the last token yet read. */
  private SourceInfo _loc(Token first) {
    return new SourceInfo(_currentFile,
                          first.beginLine,
                          first.beginColumn,
                          token.endLine,
                          token.endColumn);
  }

  /** Creates a source location that starts at the given first AST piece and ends in the last token yet read. */
  private SourceInfo _loc(JExpressionIF first) {
    return new SourceInfo(_currentFile,
                          first.getSourceInfo().getStartLine(),
                          first.getSourceInfo().getStartColumn(),
                          token.endLine,
                          token.endColumn);
  }

  private void _throwParseException(String message) throws ParseException {
    // The error typically occurs on the next token.
    Token t = token;
/* The following three lines are commented out as a wild guess as to what is going wrong in parsing erroneous .dj files.
 * Corky 11-11-14 after encountering NullPointerExceptions in the testShouldBeErrors test methods in ElementaryLevelTest 
 * IntermediateLevelTest.  The initialise method in the generated parser appeared to performing this next operation as well,
 * generating the NullPoinerException in some cases.  This fix appears to work.  Amazing ...
 */
//    if (token.next != null) {
//      t = token.next;
//    }
    // If a certain token or sequence of tokens is expected, display it.
    ParseException pe = generateParseException();
//    if (pe.expectedTokenSequences.length == 1) {
//      message += " Expected";
//      for (int i = 0; i < pe.expectedTokenSequences.length; i++) {
//        message += " " + pe.tokenImage[pe.expectedTokenSequences[0][i]];
//      }
//      message += ".";
//    }
    try {jj_input_stream.inputStream.close(); //TODO: is this crazy?
    }
    catch (java.io.IOException e) {
      System.out.println("I couldn't close the stream!");
    }

    throw new JExprParseException(_currentFile, message, t, pe.expectedTokenSequences, tokenImage);
//    _errors.add(new ParseException(_currentFile, message, t, null, tokenImage);
  }

  private void _throwParseException(ParseException pe, String message) throws ParseException {
    // Use the embedded error message if thrown from our code
    if (pe instanceof JExprParseException) {
      message = pe.getMessage();
    }

    _throwParseException(message);
  }

  private String _getTokenImage() {
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < tokenImage.length; i++) {
      sb.append(tokenImage[i] + " ");
    }
    return new String(sb).trim();
  }

  private boolean _isAbstract(ModifiersAndVisibility mav) {
    String[] modifiers = mav.getModifiers();
    for (int i = 0; i < modifiers.length; i++) {
      if (modifiers[i].equals("abstract")) {
        return true;
      }
    }
    return false;
  }

  void _errorChar(char c) throws ParseException {_throwParseException("'" + c + "' expected.");
  }

  void _errorString(String s) throws ParseException {StringBuffer message = new StringBuffer();
    for (int i = 0; i < s.length(); i++) {
      if (i > 0) {
        if (i == (s.length() - 1)) {
          message.append(" or ");
        }
        else {
          message.append(", ");
        }
      }
      message.append(s.charAt(i));
    }
    _throwParseException(message.toString() + " expected.");
  }

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/* Program structuring syntax follows. */
  final public 
SourceFile SourceFile() throws ParseException {LinkedList<PackageStatement> packageStatements = new LinkedList<PackageStatement>();
  LinkedList<ImportStatement> importStatements = new LinkedList<ImportStatement>();
  LinkedList<TypeDefBase> types = new LinkedList<TypeDefBase>();
  PackageStatement tempP;
  ImportStatement tempI;
  TypeDefBase tempT;
  Token first = getToken(1);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PACKAGE:{
        tempP = PackageStatement();
packageStatements.addLast(tempP);
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IMPORT:{
          ;
          break;
          }
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
        tempI = ImportStatement();
importStatements.addLast(tempI);
      }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ABSTRACT:
        case CLASS:
        case FINAL:
        case INTERFACE:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case STRICTFP:
        case STATIC:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOLATILE:{
          ;
          break;
          }
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
        if (jj_2_1(2147483647)) {
          tempT = ClassDef();
types.addLast(tempT);
        } else if (jj_2_2(2147483647)) {
          tempT = InterfaceDef();
types.addLast(tempT);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(0);
{if ("" != null) return new SourceFile(_loc(first),
                             packageStatements.toArray(new PackageStatement[packageStatements.size()]),
                             importStatements.toArray(new ImportStatement[importStatements.size()]),
                             types.toArray(new TypeDefBase[types.size()]));}
    } catch (ParseException pe) {
//    if (pe.currentToken.next != null && pe.currentToken.next.kind == EOF) {
//      _throwParseException(pe, "'}' expected.");
//    }
//    else {
    /** Hmm, how to also indicate that interfaces can appear here w/o messing up elementary level? */
      _throwParseException(pe, "A class declaration must appear here.");
//    }

    }
    throw new Error("Missing return statement in function");
  }

//JExpression JExpression() :
//{
//  JExpression ret;
//}
//{
//  ( ret = Operator() |
//    LOOKAHEAD(MethodDefLookahead())
//    ret = MethodDef() |
//    LOOKAHEAD(VariableDeclarationLookahead())
//    ret = VariableDeclaration() |
//    LOOKAHEAD(<IDENTIFIER> <DOT>)
//    ret = CompoundWord() |   
//    ret = Word() |
//    ret = Literal() |
//    ret = Bracketed() |
//    ret = Braced() |
//    ret = Parenthesized() |
//    LOOKAHEAD( ( <ABSTRACT> | <FINAL> | <PUBLIC> | <STRICTFP> )* <CLASS> )
//    ret = ClassDef() |
//    LOOKAHEAD( ( <STATIC> | <ABSTRACT> | <FINAL> | <PUBLIC> | <PROTECTED> | <PRIVATE> )* <INTERFACE> )
//    ret = InterfaceDef() |
////    ret = CommaSeparatedList() |
//    //ret = AngleBracketed() |
////    ret = LineCommented() |
////    ret = BlockCommented() |
////    ret = DocCommented() |
//    ret = Statement()
////    ret = BracedStatement()
//     
//  )
//  {
//    return ret;
//  }
//}
  final public 
void MethodDefLookahead() throws ParseException {
    ModifiersAndVisibility();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LT:{
      TypeParameters();
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    ReturnType();
    jj_consume_token(IDENTIFIER);
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FINAL:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:{
      FormalParameter();
      break;
      }
    case RPAREN:{
      jj_consume_token(RPAREN);
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ConstructorDefLookahead() throws ParseException {
    ModifiersAndVisibility();
    jj_consume_token(IDENTIFIER);
    FormalParameters();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case THROWS:{
      jj_consume_token(THROWS);
      break;
      }
    case LBRACE:{
      jj_consume_token(LBRACE);
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// This production is to determine lookahead only.  It will be used instead
// of MethodDefLookahead because of the added complexity of
// parametric methods and types fooling the lookahead.
  final public void VariableDeclarationLookahead() throws ParseException {
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case TRANSIENT:
      case VOLATILE:{
        ;
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PUBLIC:{
        jj_consume_token(PUBLIC);
        break;
        }
      case PROTECTED:{
        jj_consume_token(PROTECTED);
        break;
        }
      case PRIVATE:{
        jj_consume_token(PRIVATE);
        break;
        }
      case STATIC:{
        jj_consume_token(STATIC);
        break;
        }
      case ABSTRACT:{
        jj_consume_token(ABSTRACT);
        break;
        }
      case FINAL:{
        jj_consume_token(FINAL);
        break;
        }
      case TRANSIENT:{
        jj_consume_token(TRANSIENT);
        break;
        }
      case VOLATILE:{
        jj_consume_token(VOLATILE);
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    Type();
    jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SEMICOLON:{
      jj_consume_token(SEMICOLON);
      break;
      }
    case ASSIGN:{
      jj_consume_token(ASSIGN);
      break;
      }
    case COMMA:{
      jj_consume_token(COMMA);
      break;
      }
    case LBRACKET:{
      jj_consume_token(LBRACKET);
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public PackageStatement PackageStatement() throws ParseException {CompoundWord cw;
  Token first = getToken(1);
    jj_consume_token(PACKAGE);
    try {
      cw = CompoundWord();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SEMICOLON:{
        jj_consume_token(SEMICOLON);
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        _errorChar(';');
      }
//{ System.out.println("cw = " + cw); 
      {if ("" != null) return new PackageStatement(_loc(first), cw);}
    } catch (ParseException pe) {
_throwParseException(pe, "Illegal package name!");
    }
    throw new Error("Missing return statement in function");
  }

  final public ImportStatement ImportStatement() throws ParseException {CompoundWord cw;
  Token first = getToken(1);
    jj_consume_token(IMPORT);
    try {
      cw = CompoundWord();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DOT:{
        jj_consume_token(DOT);
        jj_consume_token(STAR);
        jj_consume_token(SEMICOLON);
{if ("" != null) return new PackageImportStatement(_loc(first), cw);}
        break;
        }
      default:
        jj_la1[11] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SEMICOLON:{
          jj_consume_token(SEMICOLON);
          break;
          }
        default:
          jj_la1[10] = jj_gen;
          _errorChar(';');
        }
{if ("" != null) return new ClassImportStatement(_loc(first), cw);}
      }
    } catch (ParseException pe) {
_throwParseException(pe, "Illegal import name!");
    }
    throw new Error("Missing return statement in function");
  }

  final public CompoundWord CompoundWord() throws ParseException {Word word; LinkedList<Word> list = new LinkedList<Word>();
    word = Word();
list.add(word);
    label_4:
    while (true) {
      if (jj_2_3(2)) {
        ;
      } else {
        break label_4;
      }
      jj_consume_token(DOT);
      word = Word();
list.add(word);
    }
{if ("" != null) return new CompoundWord(_loc(list.getFirst()), list.toArray(new Word[list.size()]));}
    throw new Error("Missing return statement in function");
  }

  final public ModifiersAndVisibility ModifiersAndVisibility() throws ParseException {LinkedList<String> words = new LinkedList<String>();
  Token t;
  Token first = getToken(1);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STRICTFP:
      case STATIC:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:{
        ;
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PUBLIC:{
        t = jj_consume_token(PUBLIC);
        break;
        }
      case PROTECTED:{
        t = jj_consume_token(PROTECTED);
        break;
        }
      case PRIVATE:{
        t = jj_consume_token(PRIVATE);
        break;
        }
      case STATIC:{
        t = jj_consume_token(STATIC);
        break;
        }
      case ABSTRACT:{
        t = jj_consume_token(ABSTRACT);
        break;
        }
      case FINAL:{
        t = jj_consume_token(FINAL);
        break;
        }
      case TRANSIENT:{
        t = jj_consume_token(TRANSIENT);
        break;
        }
      case VOLATILE:{
        t = jj_consume_token(VOLATILE);
        break;
        }
      case NATIVE:{
        t = jj_consume_token(NATIVE);
        break;
        }
      case SYNCHRONIZED:{
        t = jj_consume_token(SYNCHRONIZED);
        break;
        }
      case STRICTFP:{
        t = jj_consume_token(STRICTFP);
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
words.addLast(t.image);
    }
// If there are no modifiers, then we make our own SourceInfo that
   // points to the beginning of the following token.
   // Otherwise, the coordinates are backwards.
    SourceInfo si;
    if (words.size() == 0) {
      si = new SourceInfo(_currentFile,
                          first.beginLine,
                          first.beginColumn,
                          first.beginLine,
                          first.beginColumn);
    }
    else {
      si = _loc(first);
    }
    {if ("" != null) return new ModifiersAndVisibility(si, words.toArray(new String[words.size()]));}
    throw new Error("Missing return statement in function");
  }

  final public ClassDef ClassDef() throws ParseException {ModifiersAndVisibility modifiers;
  UnmodifiedClassDef decl;
  Token first = getToken(1);
  _inInterface = false;
    modifiers = ModifiersAndVisibility();
    decl = UnmodifiedClassDef();
// parse the modifiers later
//    if ((mav.isStatic) ||
//        (mav.visibility == Visibility.PRIVATE) ||
//        (mav.visibility == Visibility.PROTECTED))
//    {
//      throw new RuntimeException("Invalid modifiers for top-level class!");
//    }

    {if ("" != null) return new ClassDef(_loc(first),
                        modifiers,
                        decl.name,
                        decl.typeParameters,
                        decl.superclass,
                        decl.interfaces,
                        decl.body);}
    throw new Error("Missing return statement in function");
  }

  final public UnmodifiedClassDef UnmodifiedClassDef() throws ParseException {UnmodifiedClassDef decl = new UnmodifiedClassDef();
  Word name;
    jj_consume_token(CLASS);
    name = Word();
decl.name = name;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LT:{
      decl.typeParameters = TypeParameters();
      break;
      }
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTENDS:{
      jj_consume_token(EXTENDS);
      decl.superclass = ClassOrInterfaceType();
      break;
      }
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IMPLEMENTS:{
      jj_consume_token(IMPLEMENTS);
      decl.interfaces = NameList();
      break;
      }
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    //    (<LBRACE> | _errorChar('{'))
       decl.body = BracedBody();
{if ("" != null) return decl;}
    throw new Error("Missing return statement in function");
  }

  final public InnerClassDef InnerClassDef() throws ParseException {ModifiersAndVisibility modifiers;
  UnmodifiedClassDef decl;
  Token first = getToken(1);
    modifiers = ModifiersAndVisibility();
    decl = UnmodifiedClassDef();
{if ("" != null) return new InnerClassDef(_loc(first),
                             modifiers,
                             decl.name,
                             decl.typeParameters,
                             decl.superclass,
                             decl.interfaces,
                             decl.body);}
    throw new Error("Missing return statement in function");
  }

//  <CLASS>
//    
//    name = Word()
//    [ typeParams = TypeParameters() ]
//
//    [ <EXTENDS> superClass = ClassOrInterfaceType() ]
//    
//    [ <IMPLEMENTS> interfaces = NameList() ]
//
//  body = BracedBody() {
//    return new ClassDef(_loc(first),
//                                modifiers,
//                                name,
//                                typeParams,
//                                superClass,
//                                interfaces,
//                                body);
//  }
//}
  final public 
InterfaceDef InterfaceDef() throws ParseException {ModifiersAndVisibility modifiers;
  UnmodifiedInterfaceDef decl;
  Token first = getToken(1);
  _inInterface = true;
    modifiers = ModifiersAndVisibility();
    decl = UnmodifiedInterfaceDef();
// parse the modifiers later
//    if ((mav.isStatic) ||
//        (mav.visibility == Visibility.PRIVATE) ||
//        (mav.visibility == Visibility.PROTECTED) ||
//        (mav.modifier == ClassModifier.FINAL))
//    {
//      throw new RuntimeException("invalid modifiers for top-level interface");
//    }

    {if ("" != null) return new InterfaceDef(_loc(first),
                            modifiers,
                            decl.name,
                            decl.typeParameters,
                            decl.superinterfaces,
                            decl.body);}
    throw new Error("Missing return statement in function");
  }

  final public UnmodifiedInterfaceDef UnmodifiedInterfaceDef() throws ParseException {UnmodifiedInterfaceDef decl = new UnmodifiedInterfaceDef();
  BracedBody body;
  Word name;
    jj_consume_token(INTERFACE);
    name = Word();
decl.name = name;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LT:{
      decl.typeParameters = TypeParameters();
      break;
      }
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTENDS:{
      jj_consume_token(EXTENDS);
      decl.superinterfaces = NameList();
      break;
      }
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    body = BracedBody();
decl.body = body;
    {if ("" != null) return decl;}
    throw new Error("Missing return statement in function");
  }

  final public InnerInterfaceDef InnerInterfaceDef() throws ParseException {ModifiersAndVisibility modifiers;
  UnmodifiedInterfaceDef decl;
  Token first = getToken(1);
  boolean oldInInterface = _inInterface;
  _inInterface = true;
    modifiers = ModifiersAndVisibility();
    decl = UnmodifiedInterfaceDef();
_inInterface = oldInInterface;
    {if ("" != null) return new InnerInterfaceDef(_loc(first),
                            modifiers,
                            decl.name,
                            decl.typeParameters,
                            decl.superinterfaces,
                            decl.body);}
    throw new Error("Missing return statement in function");
  }

  final public BracedBody BracedBody() throws ParseException {UnbracedBody body; Token first = getToken(1);
    jj_consume_token(LBRACE);
    body = UnbracedBody();
    jj_consume_token(RBRACE);
{if ("" != null) return new BracedBody(_loc(first), body.getStatements());}
    throw new Error("Missing return statement in function");
  }

  final public UnbracedBody UnbracedBody() throws ParseException {LinkedList<BodyItemI> items = new LinkedList<BodyItemI>(); BodyItemI temp; Token first = getToken(1);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CLASS:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case FOR:
      case IF:
      case INSTANCEOF:
      case INT:
      case INTERFACE:
      case LONG:
      case NATIVE:
      case NEW:
      case NULL:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case RETURN:
      case SHORT:
      case STRICTFP:
      case STATIC:
      case SUPER:
      case SWITCH:
      case SYNCHRONIZED:
      case THIS:
      case THROW:
      case TRANSIENT:
      case TRUE:
      case TRY:
      case VOID:
      case VOLATILE:
      case WHILE:
      case DECIMAL_LITERAL:
      case HEX_LITERAL:
      case OCTAL_LITERAL:
      case LONG_DECIMAL_LITERAL:
      case LONG_HEX_LITERAL:
      case LONG_OCTAL_LITERAL:
      case DOUBLE_FLOATING_POINT_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case LBRACKET:
      case SEMICOLON:
      case DOT:
      case ASSIGN:
      case GT:
      case LT:
      case BANG:
      case TILDE:
      case HOOK:
      case EQ:
      case LE:
      case GE:
      case NE:
      case SC_OR:
      case SC_AND:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
      case STAR:
      case SLASH:
      case BIT_AND:
      case BIT_OR:
      case XOR:
      case REM:
      case LSHIFT:
      case RSSHIFT1:
      case RUSHIFT1:
      case PLUSASSIGN:
      case MINUSASSIGN:
      case STARASSIGN:
      case SLASHASSIGN:
      case ANDASSIGN:
      case ORASSIGN:
      case XORASSIGN:
      case REMASSIGN:
      case LSHIFTASSIGN:
      case RSIGNEDSHIFTASSIGN:
      case RUNSIGNEDSHIFTASSIGN:{
        ;
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        break label_6;
      }
      temp = BodyItem();
items.addLast(temp);
    }
{if ("" != null) return new UnbracedBody(_loc(first), items.toArray(new BodyItemI[items.size()]));}
    throw new Error("Missing return statement in function");
  }

// A BodyItem is a method declaration, field declaration, statements, initializer, constructor, or inner declaration.
  final public BodyItemI BodyItem() throws ParseException {BodyItemI temp;
    try {
      if (jj_2_4(2147483647)) {
        temp = InnerClassDef();
      } else if (jj_2_5(2147483647)) {
        temp = InnerInterfaceDef();
      } else if (jj_2_6(2)) {
        temp = Initializer();
      } else if (jj_2_7(2147483647)) {
        temp = MethodDef();
      } else if (jj_2_8(2147483647)) {
        temp = ConstructorDef();
      } else if (jj_2_9(2147483647)) {
        temp = VariableDeclaration();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SEMICOLON:{
          jj_consume_token(SEMICOLON);
          break;
          }
        default:
          jj_la1[20] = jj_gen;
          _errorString(";(");
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case BOOLEAN:
        case BREAK:
        case BYTE:
        case CHAR:
        case CONTINUE:
        case DO:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case FOR:
        case IF:
        case INSTANCEOF:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case RETURN:
        case SHORT:
        case SUPER:
        case SWITCH:
        case SYNCHRONIZED:
        case THIS:
        case THROW:
        case TRUE:
        case TRY:
        case VOID:
        case WHILE:
        case DECIMAL_LITERAL:
        case HEX_LITERAL:
        case OCTAL_LITERAL:
        case LONG_DECIMAL_LITERAL:
        case LONG_HEX_LITERAL:
        case LONG_OCTAL_LITERAL:
        case DOUBLE_FLOATING_POINT_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LBRACE:
        case LBRACKET:
        case SEMICOLON:
        case DOT:
        case ASSIGN:
        case GT:
        case LT:
        case BANG:
        case TILDE:
        case HOOK:
        case EQ:
        case LE:
        case GE:
        case NE:
        case SC_OR:
        case SC_AND:
        case INCR:
        case DECR:
        case PLUS:
        case MINUS:
        case STAR:
        case SLASH:
        case BIT_AND:
        case BIT_OR:
        case XOR:
        case REM:
        case LSHIFT:
        case RSSHIFT1:
        case RUSHIFT1:
        case PLUSASSIGN:
        case MINUSASSIGN:
        case STARASSIGN:
        case SLASHASSIGN:
        case ANDASSIGN:
        case ORASSIGN:
        case XORASSIGN:
        case REMASSIGN:
        case LSHIFTASSIGN:
        case RSIGNEDSHIFTASSIGN:
        case RUNSIGNEDSHIFTASSIGN:{
          temp = Statement();
          break;
          }
        default:
          jj_la1[21] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
{if ("" != null) return temp;}
    } catch (ParseException pe) {
_throwParseException(pe, "This statement or expression is improperly formatted or not allowed in a class body");
    }
    throw new Error("Missing return statement in function");
  }

  final public MethodDef MethodDef() throws ParseException {Token first = getToken(1);
  ModifiersAndVisibility modifiers;
  TypeParameter[] typeParams = new TypeParameter[0];
  ReturnTypeI returnType;
  Word name;
  FormalParameter[] params;
  ReferenceType[] throwsArray = new ReferenceType[0];
  BracedBody body;
    try {
      modifiers = ModifiersAndVisibility();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LT:{
        typeParams = TypeParameters();
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      returnType = ReturnType();
      name = Word();
      params = FormalParameters();
      label_7:
      while (true) {
        if (jj_2_10(2147483647)) {
          ;
        } else {
          break label_7;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
if (returnType instanceof Type) {
        returnType = new ArrayType(_loc(returnType), ((Type)returnType).getName() + "[]", (Type) returnType);
      }
      else { // void return
        _throwParseException("Cannot have method return array if base type is void!");
      }
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case THROWS:{
        jj_consume_token(THROWS);
        throwsArray = NameList();
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        ;
      }
if (!_isAbstract(modifiers) && !_inInterface) {
      body = ConcreteMethodBody();
      {if ("" != null) return new ConcreteMethodDef(_loc(first),
                                   modifiers,
                                   typeParams,
                                   returnType,
                                   name,
                                   params,
                                   throwsArray,
                                   body);}
    }
    else {
      AbstractMethodBody();
      {if ("" != null) return new AbstractMethodDef(_loc(first),
                                   modifiers,
                                   typeParams,
                                   returnType,
                                   name,
                                   params,
                                   throwsArray);}
    }
    } catch (ParseException pe) {
_throwParseException(pe, "This cannot appear in a method declaration!");
    }
    throw new Error("Missing return statement in function");
  }

  final public BracedBody ConcreteMethodBody() throws ParseException {BracedBody body;
    body = BracedBody();
{if ("" != null) return body;}
    throw new Error("Missing return statement in function");
  }

  final public void AbstractMethodBody() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SEMICOLON:{
      jj_consume_token(SEMICOLON);
      break;
      }
    default:
      jj_la1[24] = jj_gen;
      _errorChar(';');
    }
  }

  final public VariableDeclaration VariableDeclaration() throws ParseException {ModifiersAndVisibility modifiers;
  LinkedList<VariableDeclarator> variableDeclarators;
  Token first = getToken(1);
    try {
      modifiers = ModifiersAndVisibility();
      variableDeclarators = VariableDeclaratorList();
{if ("" != null) return new VariableDeclaration(_loc(first),
                                     modifiers,
          variableDeclarators.toArray(new VariableDeclarator[variableDeclarators.size()]));}
    } catch (ParseException pe) {
_throwParseException(pe, "This is not a valid variable declaration!");
    }
    throw new Error("Missing return statement in function");
  }

  final public ReferenceType[] NameList() throws ParseException {LinkedList<ReferenceType> list = new LinkedList<ReferenceType>();
  ReferenceType temp;
    temp = ClassOrInterfaceType();
list.add(temp);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      temp = ClassOrInterfaceType();
list.add(temp);
    }
{if ("" != null) return list.toArray(new ReferenceType[list.size()]);}
    throw new Error("Missing return statement in function");
  }

  final public ReturnTypeI ReturnType() throws ParseException {ReturnTypeI ret;
  Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case VOID:{
      jj_consume_token(VOID);
ret = new VoidReturn(_loc(first), "void");
      break;
      }
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:{
      ret = Type();
      break;
      }
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public FormalParameter[] FormalParameters() throws ParseException {LinkedList<FormalParameter> list = new LinkedList<FormalParameter>();
  FormalParameter temp;
  Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      jj_consume_token(LPAREN);
      break;
      }
    default:
      jj_la1[27] = jj_gen;
      _errorChar('(');
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FINAL:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:{
      temp = FormalParameter();
list.add(temp);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[28] = jj_gen;
          break label_9;
        }
        jj_consume_token(COMMA);
        temp = FormalParameter();
list.add(temp);
      }
      break;
      }
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RPAREN:{
      jj_consume_token(RPAREN);
      break;
      }
    default:
      jj_la1[30] = jj_gen;
      _errorString("),");
    }
{if ("" != null) return list.toArray(new FormalParameter[list.size()]);}
    throw new Error("Missing return statement in function");
  }

  final public FormalParameter FormalParameter() throws ParseException {boolean isFinal = false;
  Type type;
  VariableDeclarator declarator;
  Token first = getToken(1);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FINAL:{
        jj_consume_token(FINAL);
isFinal = true;
        break;
        }
      default:
        jj_la1[31] = jj_gen;
        ;
      }
      type = Type();
      declarator = VariableDeclarator(type);
if (declarator instanceof InitializedVariableDeclarator) {
        _throwParseException("Cannot assign values to parameters!");
      }
      {if ("" != null) return new FormalParameter(_loc(first), declarator, isFinal);}
    } catch (ParseException e) {
_throwParseException("This is an invalid formal parameter: make sure that you have specified a correctly formatted type name and identifier!");
    }
    throw new Error("Missing return statement in function");
  }

  final public ConstructorDef ConstructorDef() throws ParseException {ModifiersAndVisibility visibility;
  Word name = null;
  FormalParameter[] formalParameters;
  ReferenceType[] throwsArray = new ReferenceType[0];
  BracedBody code;
  Token first = getToken(1);
    try {
      visibility = ModifiersAndVisibility();
      //      (name = <IDENTIFIER> | _errorString("identifier"))
            name = Word();
      formalParameters = FormalParameters();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case THROWS:{
        jj_consume_token(THROWS);
        throwsArray = NameList();
        break;
        }
      default:
        jj_la1[32] = jj_gen;
        ;
      }
      code = BracedBody();
{if ("" != null) return new ConstructorDef(_loc(first),
                                name,
                                visibility,
                                formalParameters,
                                throwsArray,
                                code);}
    } catch (ParseException pe) {
_throwParseException(pe, "This cannot appear in a constructor definition!");
    }
    throw new Error("Missing return statement in function");
  }

  final public Initializer Initializer() throws ParseException {boolean isStatic = false;
  Block code;
  Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STATIC:{
      jj_consume_token(STATIC);
isStatic = true;
      break;
      }
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    code = Block();
if (isStatic) {
      {if ("" != null) return new StaticInitializer(_loc(first), code);}
    }
    else {
      {if ("" != null) return new InstanceInitializer(_loc(first), code);}
    }
    throw new Error("Missing return statement in function");
  }

/*
 * Type & name syntax follows.
 */
  final public 
Type Type() throws ParseException {Type type;
  Token first = getToken(1);
    if (jj_2_11(3)) {
      type = PrimitiveType();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        type = ReferenceType();
        break;
        }
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    label_10:
    while (true) {
      if (jj_2_12(2147483647)) {
        ;
      } else {
        break label_10;
      }
      jj_consume_token(LBRACKET);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RBRACKET:{
        jj_consume_token(RBRACKET);
        break;
        }
      default:
        jj_la1[35] = jj_gen;
        _errorChar(']');
      }
type = new ArrayType(_loc(first), type.getName() + "[]", type);
    }
{if ("" != null) return type;}
    throw new Error("Missing return statement in function");
  }

  final public PrimitiveType PrimitiveType() throws ParseException {Token name;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:{
      name = jj_consume_token(BOOLEAN);
      break;
      }
    case CHAR:{
      name = jj_consume_token(CHAR);
      break;
      }
    case BYTE:{
      name = jj_consume_token(BYTE);
      break;
      }
    case SHORT:{
      name = jj_consume_token(SHORT);
      break;
      }
    case INT:{
      name = jj_consume_token(INT);
      break;
      }
    case LONG:{
      name = jj_consume_token(LONG);
      break;
      }
    case FLOAT:{
      name = jj_consume_token(FLOAT);
      break;
      }
    case DOUBLE:{
      name = jj_consume_token(DOUBLE);
      break;
      }
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return new PrimitiveType(_loc(name), name.image);}
    throw new Error("Missing return statement in function");
  }

  final public ReferenceType ReferenceType() throws ParseException {ReferenceType type;
    if (jj_2_13(2)) {
      type = ClassOrInterfaceType();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        type = TypeVariable();
        break;
        }
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return type;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayType ArrayType() throws ParseException {Type elemType;
  ArrayType arrayType = null;
  Token first = getToken(1);
    if (jj_2_14(2)) {
      elemType = PrimitiveType();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        elemType = ReferenceType();
        break;
        }
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    label_11:
    while (true) {
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
if (arrayType == null) {
        arrayType = new ArrayType(_loc(first), elemType.getName() + "[]", elemType);
      }
      else {
        arrayType = new ArrayType(_loc(first), arrayType.getName() + "[]", arrayType);
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:{
        ;
        break;
        }
      default:
        jj_la1[39] = jj_gen;
        break label_11;
      }
    }
{if ("" != null) return arrayType;}
    throw new Error("Missing return statement in function");
  }

  final public TypeVariable TypeVariable() throws ParseException {Token name;
    name = jj_consume_token(IDENTIFIER);
{if ("" != null) return new TypeVariable(_loc(name), name.image);}
    throw new Error("Missing return statement in function");
  }

/** have to break out each period inside the name. */
  final public ReferenceType ClassOrInterfaceType() throws ParseException {Type[] typeArguments = new Type[0];
  Token identToken;
  ReferenceType type;
    identToken = jj_consume_token(IDENTIFIER);
    if (jj_2_15(2147483647)) {
      typeArguments = TypeArguments();
    } else {
      ;
    }
type = new ClassOrInterfaceType(_loc(identToken), identToken.image, typeArguments);
    typeArguments = new Type[0];
    label_12:
    while (true) {
      if (jj_2_16(2)) {
        ;
      } else {
        break label_12;
      }
      jj_consume_token(DOT);
      identToken = jj_consume_token(IDENTIFIER);
      if (jj_2_17(2147483647)) {
        typeArguments = TypeArguments();
      } else {
        ;
      }
ClassOrInterfaceType right = new ClassOrInterfaceType(_loc(identToken), identToken.image, typeArguments);
      typeArguments = new Type[0];
      type = new MemberType(_loc(type), type.getName() + "." + right.getName(), type, right);
    }
{if ("" != null) return type;}
    throw new Error("Missing return statement in function");
  }

  final public Type[] TypeArguments() throws ParseException {LinkedList<Type> list = new LinkedList<Type>();
  Type temp;
    jj_consume_token(LT);
    if (jj_2_18(2147483647)) {
      temp = ArrayType();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        temp = ReferenceType();
        break;
        }
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
list.add(temp);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[41] = jj_gen;
        break label_13;
      }
      jj_consume_token(COMMA);
      if (jj_2_19(2147483647)) {
        temp = ArrayType();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:{
          temp = ReferenceType();
          break;
          }
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
list.add(temp);
    }
    RightAngledBracket();
{if ("" != null) return list.toArray(new Type[list.size()]);}
    throw new Error("Missing return statement in function");
  }

  final public TypeParameter[] TypeParameters() throws ParseException {LinkedList<TypeParameter> list = new LinkedList<TypeParameter>();
  TypeParameter temp;
    jj_consume_token(LT);
    temp = TypeFormalParameter();
list.add(temp);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[43] = jj_gen;
        break label_14;
      }
      jj_consume_token(COMMA);
      temp = TypeFormalParameter();
list.add(temp);
    }
    RightAngledBracket();
{if ("" != null) return list.toArray(new TypeParameter[list.size()]);}
    throw new Error("Missing return statement in function");
  }

  final public Token RightAngledBracket() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case GT:{
      t = jj_consume_token(GT);
      break;
      }
    case RSSHIFT1:{
      t = jj_consume_token(RSSHIFT1);
      break;
      }
    case RSSHIFT2:{
      t = jj_consume_token(RSSHIFT2);
      break;
      }
    case RUSHIFT1:{
      t = jj_consume_token(RUSHIFT1);
      break;
      }
    case RUSHIFT2:{
      t = jj_consume_token(RUSHIFT2);
      break;
      }
    case RUSHIFT3:{
      t = jj_consume_token(RUSHIFT3);
      break;
      }
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
  }

  final public TypeParameter TypeFormalParameter() throws ParseException {TypeVariable variable;
  ReferenceType bound = NO_TYPE;
  Token first = getToken(1);
    variable = TypeVariable();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTENDS:{
      jj_consume_token(EXTENDS);
      bound = ClassOrInterfaceType();
      break;
      }
    default:
      jj_la1[45] = jj_gen;
      ;
    }
{if ("" != null) return new TypeParameter(_loc(first), variable, bound);}
    throw new Error("Missing return statement in function");
  }

/*
 * Statement syntax follows.
 */
  final public 
Statement Statement() throws ParseException {Statement temp;
    try {
      if (jj_2_20(2147483647)) {
        temp = Block();
      } else if (jj_2_21(2)) {
        temp = LabeledStatement();
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SWITCH:{
          temp = SwitchStatement();
          break;
          }
        case IF:{
          temp = IfStatement();
          break;
          }
        case WHILE:{
          temp = WhileStatement();
          break;
          }
        case DO:{
          temp = DoStatement();
          break;
          }
        case FOR:{
          temp = ForStatement();
          break;
          }
        case BREAK:{
          temp = BreakStatement();
          break;
          }
        case CONTINUE:{
          temp = ContinueStatement();
          break;
          }
        case RETURN:{
          temp = ReturnStatement();
          break;
          }
        case THROW:{
          temp = ThrowStatement();
          break;
          }
        case SYNCHRONIZED:{
          temp = SynchronizedStatement();
          break;
          }
        case TRY:{
          temp = TryStatement();
          break;
          }
        default:
          jj_la1[46] = jj_gen;
          if (jj_2_22(2147483647)) {
            temp = ExpressionStatement();
          } else {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case SEMICOLON:{
              temp = EmptyStatement();
              break;
              }
            default:
              jj_la1[47] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
{if ("" != null) return temp;}
    } catch (ParseException pe) {
_throwParseException(pe, "Invalid statement.");
    }
    throw new Error("Missing return statement in function");
  }

  final public LabeledStatement LabeledStatement() throws ParseException {Word label;
  Statement statement;
    label = Word();
    jj_consume_token(COLON);
    statement = Statement();
{if ("" != null) return new LabeledStatement(_loc(label), label, statement);}
    throw new Error("Missing return statement in function");
  }

  final public Block Block() throws ParseException {BracedBody code;
    code = BracedBody();
{if ("" != null) return new Block(_loc(code), code);}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionStatement ExpressionStatement() throws ParseException {Expression exp;
    exp = Expression();
    jj_consume_token(SEMICOLON);
{if ("" != null) return new ExpressionStatement(_loc(exp), exp);}
    throw new Error("Missing return statement in function");
  }

  final public Statement SwitchStatement() throws ParseException {Expression test;
  SwitchCase tempCase;
  LinkedList<SwitchCase> caseList = new LinkedList<SwitchCase>();
  Token first = getToken(1);
    jj_consume_token(SWITCH);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      jj_consume_token(LPAREN);
      break;
      }
    default:
      jj_la1[48] = jj_gen;
      _errorChar('(');
    }
    test = Expression();
    jj_consume_token(RPAREN);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACE:{
      jj_consume_token(LBRACE);
      break;
      }
    default:
      jj_la1[49] = jj_gen;
      _errorChar('{');
    }
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CASE:
      case _DEFAULT:{
        ;
        break;
        }
      default:
        jj_la1[50] = jj_gen;
        break label_15;
      }
      tempCase = SwitchCase();
caseList.add(tempCase);
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RBRACE:{
      jj_consume_token(RBRACE);
      break;
      }
    default:
      jj_la1[51] = jj_gen;
      _errorChar('}');
    }
{if ("" != null) return new SwitchStatement(_loc(first), test, caseList.toArray(new SwitchCase[caseList.size()]));}
    throw new Error("Missing return statement in function");
  }

  final public SwitchCase SwitchCase() throws ParseException {UnbracedBody statements;
  Expression label;
  Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CASE:{
      jj_consume_token(CASE);
      label = Expression();
      jj_consume_token(COLON);
      statements = UnbracedBody();
{if ("" != null) return new LabeledCase(_loc(first), label, statements);}
      break;
      }
    case _DEFAULT:{
      jj_consume_token(_DEFAULT);
      jj_consume_token(COLON);
      statements = UnbracedBody();
{if ("" != null) return new DefaultCase(_loc(first), statements);}
      break;
      }
    default:
      jj_la1[52] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Statement IfStatement() throws ParseException {Expression testExpression;
  Statement thenStatement;
  Statement elseStatement = null;
  Token first = getToken(1);
    jj_consume_token(IF);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      jj_consume_token(LPAREN);
      break;
      }
    default:
      jj_la1[53] = jj_gen;
      _errorChar('(');
    }
    testExpression = Expression();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RPAREN:{
      jj_consume_token(RPAREN);
      break;
      }
    default:
      jj_la1[54] = jj_gen;
      _errorChar(')');
    }
    thenStatement = Statement();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ELSE:{
      jj_consume_token(ELSE);
      elseStatement = Statement();
      break;
      }
    default:
      jj_la1[55] = jj_gen;
      ;
    }
if (elseStatement == null) {
      {if ("" != null) return new IfThenStatement(_loc(first), testExpression, thenStatement);}
    }
    else {
      {if ("" != null) return new IfThenElseStatement(_loc(first), testExpression, thenStatement, elseStatement);}
    }
    throw new Error("Missing return statement in function");
  }

  final public WhileStatement WhileStatement() throws ParseException {Expression condition;
  Statement body;
  Token first = getToken(1);
    jj_consume_token(WHILE);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      jj_consume_token(LPAREN);
      break;
      }
    default:
      jj_la1[56] = jj_gen;
      _errorChar('(');
    }
    condition = Expression();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RPAREN:{
      jj_consume_token(RPAREN);
      break;
      }
    default:
      jj_la1[57] = jj_gen;
      _errorChar(')');
    }
    body = Statement();
{if ("" != null) return new WhileStatement(_loc(first), condition, body);}
    throw new Error("Missing return statement in function");
  }

  final public Statement DoStatement() throws ParseException {Expression condition;
  Statement body;
  Token first = getToken(1);
    jj_consume_token(DO);
    body = Statement();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case WHILE:{
      jj_consume_token(WHILE);
      break;
      }
    default:
      jj_la1[58] = jj_gen;
      _errorString("\u005c"while\u005c"");
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      jj_consume_token(LPAREN);
      break;
      }
    default:
      jj_la1[59] = jj_gen;
      _errorChar('(');
    }
    condition = Expression();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RPAREN:{
      jj_consume_token(RPAREN);
      break;
      }
    default:
      jj_la1[60] = jj_gen;
      _errorChar(')');
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SEMICOLON:{
      jj_consume_token(SEMICOLON);
      break;
      }
    default:
      jj_la1[61] = jj_gen;
      _errorChar(';');
    }
{if ("" != null) return new DoStatement(_loc(first), body, condition);}
    throw new Error("Missing return statement in function");
  }

  final public ForStatement ForStatement() throws ParseException {ForInitI init; ForConditionI condition; UnparenthesizedExpressionList update; Statement body; Token first = getToken(1);
    jj_consume_token(FOR);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      jj_consume_token(LPAREN);
      break;
      }
    default:
      jj_la1[62] = jj_gen;
      _errorChar('(');
    }
    init = ForInit();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SEMICOLON:{
      jj_consume_token(SEMICOLON);
      break;
      }
    default:
      jj_la1[63] = jj_gen;
      _errorChar(';');
    }
    condition = ForCondition();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SEMICOLON:{
      jj_consume_token(SEMICOLON);
      break;
      }
    default:
      jj_la1[64] = jj_gen;
      _errorChar(';');
    }
    update = UnparenthesizedExpressionList();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RPAREN:{
      jj_consume_token(RPAREN);
      break;
      }
    default:
      jj_la1[65] = jj_gen;
      _errorChar(')');
    }
    body = Statement();
{if ("" != null) return new ForStatement(_loc(first), init, condition, update, body);}
    throw new Error("Missing return statement in function");
  }

  final public ForInitI ForInit() throws ParseException {ForInitI init;
    if (jj_2_23(2147483647)) {
      init = VariableDeclaration();
    } else {
      init = UnparenthesizedExpressionList();
    }
{if ("" != null) return init;}
    throw new Error("Missing return statement in function");
  }

  final public ForConditionI ForCondition() throws ParseException {Expression cond; Token first = getToken(1);
    if (jj_2_24(2147483647)) {
      cond = Expression();
{if ("" != null) return cond;}
    } else {
{if ("" != null) return new EmptyForCondition(_loc(first));}
    }
    throw new Error("Missing return statement in function");
  }

  final public BreakStatement BreakStatement() throws ParseException {Word label = null;
  Token first = getToken(1);
    jj_consume_token(BREAK);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      label = Word();
      break;
      }
    default:
      jj_la1[66] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SEMICOLON:{
      jj_consume_token(SEMICOLON);
      break;
      }
    default:
      jj_la1[67] = jj_gen;
      _errorChar(';');
    }
if (label == null) {
      {if ("" != null) return new UnlabeledBreakStatement(_loc(first));}
    }
    else {
      {if ("" != null) return new LabeledBreakStatement(_loc(first), label);}
    }
    throw new Error("Missing return statement in function");
  }

  final public ContinueStatement ContinueStatement() throws ParseException {Word label = null;
  Token first = getToken(1);
    jj_consume_token(CONTINUE);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      label = Word();
      break;
      }
    default:
      jj_la1[68] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SEMICOLON:{
      jj_consume_token(SEMICOLON);
      break;
      }
    default:
      jj_la1[69] = jj_gen;
      _errorChar(';');
    }
if (label == null) {
      {if ("" != null) return new UnlabeledContinueStatement(_loc(first));}
    }
    else {
      {if ("" != null) return new LabeledContinueStatement(_loc(first), label);}
    }
    throw new Error("Missing return statement in function");
  }

  final public ReturnStatement ReturnStatement() throws ParseException {Expression value; Token first = getToken(1);
    jj_consume_token(RETURN);
    if (jj_2_25(2147483647)) {
      value = Expression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SEMICOLON:{
        jj_consume_token(SEMICOLON);
        break;
        }
      default:
        jj_la1[70] = jj_gen;
        _errorChar(';');
      }
{if ("" != null) return new ValueReturnStatement(_loc(first), value);}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SEMICOLON:{
        jj_consume_token(SEMICOLON);
        break;
        }
      default:
        jj_la1[71] = jj_gen;
        _errorChar(';');
      }
{if ("" != null) return new VoidReturnStatement(_loc(first));}
    }
    throw new Error("Missing return statement in function");
  }

  final public ThrowStatement ThrowStatement() throws ParseException {Expression exp;
  Token first = getToken(1);
    jj_consume_token(THROW);
    exp = Expression();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SEMICOLON:{
      jj_consume_token(SEMICOLON);
      break;
      }
    default:
      jj_la1[72] = jj_gen;
      _errorChar(';');
    }
{if ("" != null) return new ThrowStatement(_loc(first), exp);}
    throw new Error("Missing return statement in function");
  }

  final public SynchronizedStatement SynchronizedStatement() throws ParseException {Expression exp;
  Block block;
  Token first = getToken(1);
    jj_consume_token(SYNCHRONIZED);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LPAREN:{
      jj_consume_token(LPAREN);
      break;
      }
    default:
      jj_la1[73] = jj_gen;
      _errorChar('(');
    }
    exp = Expression();
    jj_consume_token(RPAREN);
    block = Block();
{if ("" != null) return new SynchronizedStatement(_loc(first), exp, block);}
    throw new Error("Missing return statement in function");
  }

  final public TryCatchStatement TryStatement() throws ParseException {Block tryBlock;
  LinkedList<CatchBlock> catchList = new LinkedList<CatchBlock>();
  FormalParameter catchParam;
  Block tempCatchBlock;
  Block finallyBlock = null;
  Token first = getToken(1);
  Token catchToken;
    jj_consume_token(TRY);
    tryBlock = Block();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CATCH:{
        ;
        break;
        }
      default:
        jj_la1[74] = jj_gen;
        break label_16;
      }
      catchToken = jj_consume_token(CATCH);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:{
        jj_consume_token(LPAREN);
        break;
        }
      default:
        jj_la1[75] = jj_gen;
        _errorChar('(');
      }
      catchParam = FormalParameter();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RPAREN:{
        jj_consume_token(RPAREN);
        break;
        }
      default:
        jj_la1[76] = jj_gen;
        _errorChar(')');
      }
      tempCatchBlock = Block();
catchList.add(new CatchBlock(_loc(catchToken), catchParam, tempCatchBlock));
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FINALLY:{
      jj_consume_token(FINALLY);
      finallyBlock = Block();
      break;
      }
    default:
      jj_la1[77] = jj_gen;
      ;
    }
CatchBlock[] catches = catchList.toArray(new CatchBlock[catchList.size()]);
    if (finallyBlock == null) {
      {if ("" != null) return new NormalTryCatchStatement(_loc(first), tryBlock, catches);}
    }
    else {
      {if ("" != null) return new TryCatchFinallyStatement(_loc(first), tryBlock, catches, finallyBlock);}
    }
    throw new Error("Missing return statement in function");
  }

  final public EmptyStatement EmptyStatement() throws ParseException {Token first = getToken(1);
    jj_consume_token(SEMICOLON);
{if ("" != null) return new EmptyStatement(_loc(first));}
    throw new Error("Missing return statement in function");
  }

/**
 * Recognizes: Type (identifier [, initializer ] )+.
 */
  final public LinkedList<VariableDeclarator> VariableDeclaratorList() throws ParseException {LinkedList<VariableDeclarator> list = new LinkedList<VariableDeclarator>();

  Type originalType;
  VariableDeclarator current;
    try {
      originalType = Type();
      current = VariableDeclarator(originalType);
list.add(current);
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[78] = jj_gen;
          break label_17;
        }
        jj_consume_token(COMMA);
        current = VariableDeclarator(originalType);
list.add(current);
      }
{if ("" != null) return list;}
    } catch (ParseException pe) {
_throwParseException(pe, "This cannot appear in a variable declarator!");
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Recognizes an identifier with any number of possible brackets.
 * Figures out the real type by dealing with the fact
 * that [] can be either after type or after identifier!
 * Very strange syntax indeed.
 * TODO: Make sure FormalParameter (or anything else that can't have
 * initialized variable declarators to check for this).
 *
 * @param givenType  The type that was recognized before this identifier
 * @return  The pair of type and identifier. The type encompasses
 *          all levels of array []s needed (from both after the type and
 *          after the identifier).
 */
  final public VariableDeclarator VariableDeclarator(Type givenType) throws ParseException {//  VariableDeclarator decl = new VariableDeclarator();
  Type type = givenType;
  Word identifier;
  VariableInitializerI initializer = null;
    identifier = Word();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:{
        ;
        break;
        }
      default:
        jj_la1[79] = jj_gen;
        break label_18;
      }
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
type = new ArrayType(_loc(identifier), type.getName() + "[]", type);
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASSIGN:{
      jj_consume_token(ASSIGN);
      initializer = VariableInitializer();
      break;
      }
    default:
      jj_la1[80] = jj_gen;
      ;
    }
if (initializer == null) {
      {if ("" != null) return new UninitializedVariableDeclarator(_loc(identifier),
                                                 type,
                                                 identifier);}
    }
    else {
      {if ("" != null) return new InitializedVariableDeclarator(_loc(identifier),
                                               type,
                                               identifier,
                                               initializer);}
    }
    throw new Error("Missing return statement in function");
  }

  final public VariableInitializerI VariableInitializer() throws ParseException {VariableInitializerI init;
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACE:{
        init = ArrayInitializer();
{if ("" != null) return init;}
        break;
        }
      default:
        jj_la1[81] = jj_gen;
        init = Expression();
{if ("" != null) return init;}
      }
    } catch (ParseException pe) {
_throwParseException(pe, "This is an illegal variable initializer!");
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayInitializer ArrayInitializer() throws ParseException {LinkedList<VariableInitializerI> items = new LinkedList<VariableInitializerI>();
  VariableInitializerI varInit;
  Token first = getToken(1);
    try {
      jj_consume_token(LBRACE);
      varInit = VariableInitializer();
items.add(varInit);
      label_19:
      while (true) {
        if (jj_2_26(2)) {
          ;
        } else {
          break label_19;
        }
        jj_consume_token(COMMA);
        varInit = VariableInitializer();
items.add(varInit);
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        jj_consume_token(COMMA);
        break;
        }
      default:
        jj_la1[82] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RBRACE:{
        jj_consume_token(RBRACE);
        break;
        }
      default:
        jj_la1[83] = jj_gen;
        _errorChar('}');
      }
/* If the list contains only an EmptyExpression, it's actually an empty list. */
          if (items.size() == 1 && items.get(0) instanceof EmptyExpression) {
            {if ("" != null) return new ArrayInitializer(_loc(first), new VariableInitializerI[0]);}
          }
          else {
            {if ("" != null) return new ArrayInitializer(_loc(first), items.toArray(new VariableInitializerI[items.size()]));}
          }
    } catch (ParseException pe) {
_throwParseException(pe, "This is an illegal array initializer!");
    }
    throw new Error("Missing return statement in function");
  }

/*
 * Expression syntax follows.
 */
  final public 
void NonEmptyExpressionLookahead() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASSIGN:{
      jj_consume_token(ASSIGN);
      break;
      }
    case PLUSASSIGN:{
      jj_consume_token(PLUSASSIGN);
      break;
      }
    case MINUSASSIGN:{
      jj_consume_token(MINUSASSIGN);
      break;
      }
    case STARASSIGN:{
      jj_consume_token(STARASSIGN);
      break;
      }
    case SLASHASSIGN:{
      jj_consume_token(SLASHASSIGN);
      break;
      }
    case REMASSIGN:{
      jj_consume_token(REMASSIGN);
      break;
      }
    case LSHIFTASSIGN:{
      jj_consume_token(LSHIFTASSIGN);
      break;
      }
    case RSIGNEDSHIFTASSIGN:{
      jj_consume_token(RSIGNEDSHIFTASSIGN);
      break;
      }
    case RUNSIGNEDSHIFTASSIGN:{
      jj_consume_token(RUNSIGNEDSHIFTASSIGN);
      break;
      }
    case ANDASSIGN:{
      jj_consume_token(ANDASSIGN);
      break;
      }
    case ORASSIGN:{
      jj_consume_token(ORASSIGN);
      break;
      }
    case XORASSIGN:{
      jj_consume_token(XORASSIGN);
      break;
      }
    case HOOK:{
      jj_consume_token(HOOK);
      break;
      }
    case SC_OR:{
      jj_consume_token(SC_OR);
      break;
      }
    case SC_AND:{
      jj_consume_token(SC_AND);
      break;
      }
    case BIT_OR:{
      jj_consume_token(BIT_OR);
      break;
      }
    case XOR:{
      jj_consume_token(XOR);
      break;
      }
    case BIT_AND:{
      jj_consume_token(BIT_AND);
      break;
      }
    case EQ:{
      jj_consume_token(EQ);
      break;
      }
    case NE:{
      jj_consume_token(NE);
      break;
      }
    case LT:{
      jj_consume_token(LT);
      break;
      }
    case LE:{
      jj_consume_token(LE);
      break;
      }
    case GT:{
      jj_consume_token(GT);
      break;
      }
    case GE:{
      jj_consume_token(GE);
      break;
      }
    case INSTANCEOF:{
      jj_consume_token(INSTANCEOF);
      break;
      }
    case LSHIFT:{
      jj_consume_token(LSHIFT);
      break;
      }
    case RSSHIFT1:
    case RUSHIFT1:{
      RightShiftOp();
      break;
      }
    case PLUS:{
      jj_consume_token(PLUS);
      break;
      }
    case MINUS:{
      jj_consume_token(MINUS);
      break;
      }
    case STAR:{
      jj_consume_token(STAR);
      break;
      }
    case SLASH:{
      jj_consume_token(SLASH);
      break;
      }
    case REM:{
      jj_consume_token(REM);
      break;
      }
    case INCR:{
      jj_consume_token(INCR);
      break;
      }
    case DECR:{
      jj_consume_token(DECR);
      break;
      }
    case TILDE:{
      jj_consume_token(TILDE);
      break;
      }
    case BANG:{
      jj_consume_token(BANG);
      break;
      }
    case LPAREN:{
      jj_consume_token(LPAREN);
      break;
      }
    case FALSE:
    case NULL:
    case TRUE:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case OCTAL_LITERAL:
    case LONG_DECIMAL_LITERAL:
    case LONG_HEX_LITERAL:
    case LONG_OCTAL_LITERAL:
    case DOUBLE_FLOATING_POINT_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:{
      LexicalLiteral();
      break;
      }
    case NEW:{
      jj_consume_token(NEW);
      break;
      }
    case THIS:{
      jj_consume_token(THIS);
      break;
      }
    case SUPER:{
      jj_consume_token(SUPER);
      break;
      }
    case IDENTIFIER:{
      jj_consume_token(IDENTIFIER);
      break;
      }
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:{
      PrimitiveType();
      break;
      }
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Expression Expression() throws ParseException {Expression result;
    result = AssignmentExpression();
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Expression NoOpExpression() throws ParseException {Expression left; Expression right;
    left = AssignmentExpression();
    label_20:
    while (true) {
      if (jj_2_27(2147483647)) {
        ;
      } else {
        break label_20;
      }
      AssertNonEmpty();
      right = AssignmentExpression();
left = new NoOpExpression(_loc(left), left, right);
    }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
  }

  void AssertNonEmpty() throws ParseException {
  }

  final public Expression AssignmentExpression() throws ParseException {Expression name; Expression value;
    name = ConditionalExpression();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASSIGN:
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
    case LSHIFTASSIGN:
    case RSIGNEDSHIFTASSIGN:
    case RUNSIGNEDSHIFTASSIGN:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ASSIGN:{
        jj_consume_token(ASSIGN);
        value = AssignmentExpression();
{if ("" != null) return new SimpleAssignmentExpression(_loc(name), name, value);}
        break;
        }
      case PLUSASSIGN:{
        jj_consume_token(PLUSASSIGN);
        value = AssignmentExpression();
{if ("" != null) return new PlusAssignmentExpression(_loc(name), name, value);}
        break;
        }
      case MINUSASSIGN:{
        jj_consume_token(MINUSASSIGN);
        value = AssignmentExpression();
{if ("" != null) return new MinusAssignmentExpression(_loc(name), name, value);}
        break;
        }
      case STARASSIGN:{
        jj_consume_token(STARASSIGN);
        value = AssignmentExpression();
{if ("" != null) return new MultiplyAssignmentExpression(_loc(name), name, value);}
        break;
        }
      case SLASHASSIGN:{
        jj_consume_token(SLASHASSIGN);
        value = AssignmentExpression();
{if ("" != null) return new DivideAssignmentExpression(_loc(name), name, value);}
        break;
        }
      case REMASSIGN:{
        jj_consume_token(REMASSIGN);
        value = AssignmentExpression();
{if ("" != null) return new ModAssignmentExpression(_loc(name), name, value);}
        break;
        }
      case LSHIFTASSIGN:{
        jj_consume_token(LSHIFTASSIGN);
        value = AssignmentExpression();
{if ("" != null) return new LeftShiftAssignmentExpression(_loc(name), name, value);}
        break;
        }
      case RSIGNEDSHIFTASSIGN:{
        jj_consume_token(RSIGNEDSHIFTASSIGN);
        value = AssignmentExpression();
{if ("" != null) return new RightSignedShiftAssignmentExpression(_loc(name), name, value);}
        break;
        }
      case RUNSIGNEDSHIFTASSIGN:{
        jj_consume_token(RUNSIGNEDSHIFTASSIGN);
        value = AssignmentExpression();
{if ("" != null) return new RightUnsignedShiftAssignmentExpression(_loc(name), name, value);}
        break;
        }
      case ANDASSIGN:{
        jj_consume_token(ANDASSIGN);
        value = AssignmentExpression();
{if ("" != null) return new BitwiseAndAssignmentExpression(_loc(name), name, value);}
        break;
        }
      case ORASSIGN:{
        jj_consume_token(ORASSIGN);
        value = AssignmentExpression();
{if ("" != null) return new BitwiseOrAssignmentExpression(_loc(name), name, value);}
        break;
        }
      case XORASSIGN:{
        jj_consume_token(XORASSIGN);
        value = AssignmentExpression();
{if ("" != null) return new BitwiseXorAssignmentExpression(_loc(name), name, value);}
        break;
        }
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[86] = jj_gen;
      ;
    }
{if ("" != null) return name;}
    throw new Error("Missing return statement in function");
  }

  final public Expression ConditionalExpression() throws ParseException {Expression condition; Expression forTrue; Expression forFalse;
    condition = OrExpression();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case HOOK:{
      jj_consume_token(HOOK);
      forTrue = Expression();
      jj_consume_token(COLON);
      forFalse = ConditionalExpression();
{if ("" != null) return new ConditionalExpression(_loc(condition), condition, forTrue, forFalse);}
      break;
      }
    default:
      jj_la1[87] = jj_gen;
      ;
    }
{if ("" != null) return condition;}
    throw new Error("Missing return statement in function");
  }

  final public Expression OrExpression() throws ParseException {Expression left; Expression right;
    left = AndExpression();
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SC_OR:{
        ;
        break;
        }
      default:
        jj_la1[88] = jj_gen;
        break label_21;
      }
      jj_consume_token(SC_OR);
      right = AndExpression();
left = new OrExpression(_loc(left), left, right);
    }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
  }

  final public Expression AndExpression() throws ParseException {Expression left; Expression right;
    left = BitwiseOrExpression();
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SC_AND:{
        ;
        break;
        }
      default:
        jj_la1[89] = jj_gen;
        break label_22;
      }
      jj_consume_token(SC_AND);
      right = BitwiseOrExpression();
left = new AndExpression(_loc(left), left, right);
    }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
  }

  final public Expression BitwiseOrExpression() throws ParseException {Expression left; Expression right;
    left = BitwiseXorExpression();
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BIT_OR:{
        ;
        break;
        }
      default:
        jj_la1[90] = jj_gen;
        break label_23;
      }
      jj_consume_token(BIT_OR);
      right = BitwiseXorExpression();
left = new BitwiseOrExpression(_loc(left), left, right);
    }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
  }

  final public Expression BitwiseXorExpression() throws ParseException {Expression left; Expression right;
    left = BitwiseAndExpression();
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case XOR:{
        ;
        break;
        }
      default:
        jj_la1[91] = jj_gen;
        break label_24;
      }
      jj_consume_token(XOR);
      right = BitwiseAndExpression();
left = new BitwiseXorExpression(_loc(left), left, right);
    }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
  }

  final public Expression BitwiseAndExpression() throws ParseException {Expression left; Expression right;
    left = EqualityExpression();
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BIT_AND:{
        ;
        break;
        }
      default:
        jj_la1[92] = jj_gen;
        break label_25;
      }
      jj_consume_token(BIT_AND);
      right = EqualityExpression();
left = new BitwiseAndExpression(_loc(left), left, right);
    }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
  }

  final public Expression EqualityExpression() throws ParseException {Expression left; Expression right;
    left = ComparisonExpression();
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQ:
      case NE:{
        ;
        break;
        }
      default:
        jj_la1[93] = jj_gen;
        break label_26;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQ:{
        jj_consume_token(EQ);
        right = ComparisonExpression();
left = new EqualsExpression(_loc(left), left, right);
        break;
        }
      case NE:{
        jj_consume_token(NE);
        right = ComparisonExpression();
left = new NotEqualExpression(_loc(left), left, right);
        break;
        }
      default:
        jj_la1[94] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
  }

  final public Expression ComparisonExpression() throws ParseException {Expression left; Expression right; Type type;
    left = ShiftBinaryExpression();
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INSTANCEOF:
      case GT:
      case LT:
      case LE:
      case GE:{
        ;
        break;
        }
      default:
        jj_la1[95] = jj_gen;
        break label_27;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LT:{
        jj_consume_token(LT);
        right = ShiftBinaryExpression();
left = new LessThanExpression(_loc(left), left, right);
        break;
        }
      case LE:{
        jj_consume_token(LE);
        right = ShiftBinaryExpression();
left = new LessThanOrEqualExpression(_loc(left), left, right);
        break;
        }
      case GT:{
        jj_consume_token(GT);
        right = ShiftBinaryExpression();
left = new GreaterThanExpression(_loc(left), left, right);
        break;
        }
      case GE:{
        jj_consume_token(GE);
        right = ShiftBinaryExpression();
left = new GreaterThanOrEqualExpression(_loc(left), left, right);
        break;
        }
      case INSTANCEOF:{
        jj_consume_token(INSTANCEOF);
        type = Type();
left = new InstanceofExpression(_loc(left), left, type);
        break;
        }
      default:
        jj_la1[96] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
  }

  final public Expression ShiftBinaryExpression() throws ParseException {Expression left; Expression right; Token rshift;
    left = AdditiveExpression();
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LSHIFT:
      case RSSHIFT1:
      case RUSHIFT1:{
        ;
        break;
        }
      default:
        jj_la1[97] = jj_gen;
        break label_28;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LSHIFT:{
        jj_consume_token(LSHIFT);
        right = AdditiveExpression();
left = new LeftShiftExpression(_loc(left), left, right);
        break;
        }
      case RSSHIFT1:
      case RUSHIFT1:{
        rshift = RightShiftOp();
        right = AdditiveExpression();
if (rshift.kind == RSSHIFT1) { left = new RightSignedShiftExpression(_loc(left), left, right); }
          else { left = new RightUnsignedShiftExpression(_loc(left), left, right); }
        break;
        }
      default:
        jj_la1[98] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
  }

  final public Expression AdditiveExpression() throws ParseException {Expression left; Expression right;
    left = MultiplicativeExpression();
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MINUS:{
        ;
        break;
        }
      default:
        jj_la1[99] = jj_gen;
        break label_29;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        jj_consume_token(PLUS);
        right = MultiplicativeExpression();
left = new PlusExpression(_loc(left), left, right);
        break;
        }
      case MINUS:{
        jj_consume_token(MINUS);
        right = MultiplicativeExpression();
left = new MinusExpression(_loc(left), left, right);
        break;
        }
      default:
        jj_la1[100] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
  }

  final public Expression MultiplicativeExpression() throws ParseException {Expression left; Expression right;
    left = UnaryExpression();
    label_30:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STAR:
      case SLASH:
      case REM:{
        ;
        break;
        }
      default:
        jj_la1[101] = jj_gen;
        break label_30;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STAR:{
        jj_consume_token(STAR);
        right = UnaryExpression();
left = new MultiplyExpression(_loc(left), left, right);
        break;
        }
      case SLASH:{
        jj_consume_token(SLASH);
        right = UnaryExpression();
left = new DivideExpression(_loc(left), left, right);
        break;
        }
      case REM:{
        jj_consume_token(REM);
        right = UnaryExpression();
left = new ModExpression(_loc(left), left, right);
        break;
        }
      default:
        jj_la1[102] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return left;}
    throw new Error("Missing return statement in function");
  }

  final public Expression UnaryExpression() throws ParseException {Expression value; Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INCR:{
      jj_consume_token(INCR);
      value = UnaryExpression();
{if ("" != null) return new PositivePrefixIncrementExpression(_loc(first), value);}
      break;
      }
    case DECR:{
      jj_consume_token(DECR);
      value = UnaryExpression();
{if ("" != null) return new NegativePrefixIncrementExpression(_loc(first), value);}
      break;
      }
    case PLUS:{
      jj_consume_token(PLUS);
      value = UnaryExpression();
{if ("" != null) return new PositiveExpression(_loc(first), value);}
      break;
      }
    case MINUS:{
      jj_consume_token(MINUS);
      value = UnaryExpression();
{if ("" != null) return new NegativeExpression(_loc(first), value);}
      break;
      }
    default:
      jj_la1[103] = jj_gen;
      value = UnaryExpressionNotPlusMinus();
{if ("" != null) return value;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Expression UnaryExpressionNotPlusMinus() throws ParseException {Expression value; Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TILDE:{
      jj_consume_token(TILDE);
      value = UnaryExpression();
{if ("" != null) return new BitwiseNotExpression(_loc(first), value);}
      break;
      }
    case BANG:{
      jj_consume_token(BANG);
      value = UnaryExpression();
{if ("" != null) return new NotExpression(_loc(first), value);}
      break;
      }
    default:
      jj_la1[104] = jj_gen;
      if (jj_2_28(2147483647)) {
        value = CastExpression();
{if ("" != null) return value;}
      } else {
        value = PostfixIncrementExpression();
{if ("" != null) return value;}
      }
    }
    throw new Error("Missing return statement in function");
  }

/* "CastLookahead()" is lifted directly from the Java1.5.jj grammar. */
// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
  final public void CastLookahead() throws ParseException {
    if (jj_2_29(2)) {
      jj_consume_token(LPAREN);
      PrimitiveType();
    } else if (jj_2_30(2147483647)) {
      jj_consume_token(LPAREN);
      Type();
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:{
        jj_consume_token(LPAREN);
        Type();
        jj_consume_token(RPAREN);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case TILDE:{
          jj_consume_token(TILDE);
          break;
          }
        case BANG:{
          jj_consume_token(BANG);
          break;
          }
        case LPAREN:{
          jj_consume_token(LPAREN);
          break;
          }
        case IDENTIFIER:{
          jj_consume_token(IDENTIFIER);
          break;
          }
        case THIS:{
          jj_consume_token(THIS);
          break;
          }
        case SUPER:{
          jj_consume_token(SUPER);
          break;
          }
        case NEW:{
          jj_consume_token(NEW);
          break;
          }
        case FALSE:
        case NULL:
        case TRUE:
        case DECIMAL_LITERAL:
        case HEX_LITERAL:
        case OCTAL_LITERAL:
        case LONG_DECIMAL_LITERAL:
        case LONG_HEX_LITERAL:
        case LONG_OCTAL_LITERAL:
        case DOUBLE_FLOATING_POINT_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:{
          LexicalLiteral();
          break;
          }
        default:
          jj_la1[105] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[106] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public Expression CastExpression() throws ParseException {Type type; Expression value; Token first = getToken(1);
    jj_consume_token(LPAREN);
    if (jj_2_31(2147483647)) {
      type = PrimitiveType();
      jj_consume_token(RPAREN);
      value = UnaryExpression();
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:{
        type = Type();
        jj_consume_token(RPAREN);
        value = UnaryExpressionNotPlusMinus();
        break;
        }
      default:
        jj_la1[107] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return new CastExpression(_loc(first), type, value);}
    throw new Error("Missing return statement in function");
  }

  final public Expression PostfixIncrementExpression() throws ParseException {Expression value;
    value = Primary();
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INCR:
      case DECR:{
        ;
        break;
        }
      default:
        jj_la1[108] = jj_gen;
        break label_31;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INCR:{
        jj_consume_token(INCR);
value = new PositivePostfixIncrementExpression(_loc(value), value);
        break;
        }
      case DECR:{
        jj_consume_token(DECR);
value = new NegativePostfixIncrementExpression(_loc(value), value);
        break;
        }
      default:
        jj_la1[109] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
{if ("" != null) return value;}
    throw new Error("Missing return statement in function");
  }

  final public Primary Primary() throws ParseException {Primary value;
    value = PrimaryPrefix();
    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:
      case DOT:{
        ;
        break;
        }
      default:
        jj_la1[110] = jj_gen;
        break label_32;
      }
      value = PrimarySuffix(value);
    }
{if ("" != null) return value;}
    throw new Error("Missing return statement in function");
  }

  final public Primary PrimaryPrefix() throws ParseException {Primary value; Expression nestedValue; ReturnTypeI type; Word name; ParenthesizedExpressionList args; Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case OCTAL_LITERAL:
    case LONG_DECIMAL_LITERAL:
    case LONG_HEX_LITERAL:
    case LONG_OCTAL_LITERAL:
    case DOUBLE_FLOATING_POINT_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FALSE:
      case NULL:
      case TRUE:
      case DECIMAL_LITERAL:
      case HEX_LITERAL:
      case OCTAL_LITERAL:
      case LONG_DECIMAL_LITERAL:
      case LONG_HEX_LITERAL:
      case LONG_OCTAL_LITERAL:
      case DOUBLE_FLOATING_POINT_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:{
        value = LexicalLiteral();
{if ("" != null) return value;}
        break;
        }
      case NEW:{
        value = SimpleInstantiation();
{if ("" != null) return value;}
        break;
        }
      case LPAREN:{
        jj_consume_token(LPAREN);
        nestedValue = Expression();
        jj_consume_token(RPAREN);
{if ("" != null) return new Parenthesized(_loc(first), nestedValue);}
        break;
        }
      default:
        jj_la1[113] = jj_gen;
        if (jj_2_34(2147483647)) {
          type = ReturnType();
          jj_consume_token(DOT);
          jj_consume_token(CLASS);
{if ("" != null) return new ClassLiteral(_loc(type), type);}
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case THIS:{
            jj_consume_token(THIS);
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case LPAREN:{
              args = ParenthesizedExpressionList();
{if ("" != null) return new SimpleThisConstructorInvocation(_loc(first), args);}
              break;
              }
            default:
              jj_la1[111] = jj_gen;
              ;
            }
{if ("" != null) return new SimpleThisReference(_loc(first));}
            break;
            }
          case SUPER:{
            jj_consume_token(SUPER);
            if (jj_2_32(2147483647)) {
{if ("" != null) return new SimpleSuperReference(_loc(first));}
            } else if (jj_2_33(2147483647)) {
              args = ParenthesizedExpressionList();
{if ("" != null) return new SimpleSuperConstructorInvocation(_loc(first), args);}
            } else {
              _errorChar('.');
            }
            break;
            }
          case IDENTIFIER:{
            name = Word();
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case LPAREN:{
              args = ParenthesizedExpressionList();
{if ("" != null) return new SimpleMethodInvocation(_loc(name), name, args);}
              break;
              }
            default:
              jj_la1[112] = jj_gen;
              ;
            }
{if ("" != null) return new SimpleNameReference(_loc(name), name);}
            break;
            }
          default:
            jj_la1[114] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      break;
      }
    default:
      jj_la1[115] = jj_gen;
      ;
    }
{if ("" != null) return new EmptyExpression(_loc(first));}
    throw new Error("Missing return statement in function");
  }

  final public Primary PrimarySuffix(Primary prefix) throws ParseException {Primary value; Word name; ParenthesizedExpressionList args; Expression index;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LBRACKET:{
      jj_consume_token(LBRACKET);
      index = Expression();
      jj_consume_token(RBRACKET);
{if ("" != null) return new ArrayAccess(_loc(prefix), prefix, index);}
      break;
      }
    case DOT:{
      jj_consume_token(DOT);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NEW:{
        value = ComplexInstantiation(prefix);
{if ("" != null) return value;}
        break;
        }
      case THIS:{
        jj_consume_token(THIS);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:{
          args = ParenthesizedExpressionList();
{if ("" != null) return new ComplexThisConstructorInvocation(_loc(prefix), prefix, args);}
          break;
          }
        default:
          jj_la1[116] = jj_gen;
          ;
        }
{if ("" != null) return new ComplexThisReference(_loc(prefix), prefix);}
        break;
        }
      case SUPER:{
        jj_consume_token(SUPER);
        if (jj_2_35(2147483647)) {
{if ("" != null) return new ComplexSuperReference(_loc(prefix), prefix);}
        } else if (jj_2_36(2147483647)) {
          args = ParenthesizedExpressionList();
{if ("" != null) return new ComplexSuperConstructorInvocation(_loc(prefix), prefix, args);}
        } else {
          _errorChar('.');
        }
        break;
        }
      case IDENTIFIER:{
        name = Word();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:{
          args = ParenthesizedExpressionList();
{if ("" != null) return new ComplexMethodInvocation(_loc(prefix), prefix, name, args);}
          break;
          }
        default:
          jj_la1[117] = jj_gen;
          ;
        }
{if ("" != null) return new ComplexNameReference(_loc(prefix), prefix, name);}
        break;
        }
      default:
        jj_la1[118] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[119] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public LexicalLiteral LexicalLiteral() throws ParseException {Token t; LexicalLiteral literal; Token first = getToken(1);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DECIMAL_LITERAL:
      case HEX_LITERAL:
      case OCTAL_LITERAL:
      case LONG_DECIMAL_LITERAL:
      case LONG_HEX_LITERAL:
      case LONG_OCTAL_LITERAL:{
        literal = IntegerLiteral();
{if ("" != null) return literal;}
        break;
        }
      case DOUBLE_FLOATING_POINT_LITERAL:
      case FLOATING_POINT_LITERAL:{
        literal = FloatLiteral();
{if ("" != null) return literal;}
        break;
        }
      case CHARACTER_LITERAL:{
        t = jj_consume_token(CHARACTER_LITERAL);
{if ("" != null) return new CharLiteral(_loc(t), CharConverter.unescapeChar(_stripQuotes(t.image)));}
        break;
        }
      case STRING_LITERAL:{
        t = jj_consume_token(STRING_LITERAL);
{if ("" != null) return new StringLiteral(_loc(t), CharConverter.unescapeString(_stripQuotes(t.image)));}
        break;
        }
      case FALSE:
      case TRUE:{
        literal = BooleanLiteral();
{if ("" != null) return literal;}
        break;
        }
      case NULL:{
        jj_consume_token(NULL);
{if ("" != null) return new NullLiteral(_loc(first));}
        break;
        }
      default:
        jj_la1[120] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException pe) {
_throwParseException(pe, "This is an illegal literal!");
    }
    throw new Error("Missing return statement in function");
  }

/** 
 * Differentiates between array allocations and anonymous inner class definitions
 */
  final public Instantiation SimpleInstantiation() throws ParseException {PrimitiveType tempPrimitive;
  ReferenceType tempReference;
  Instantiation temp;
  BracedBody body = null;
  ParenthesizedExpressionList arguments;
  Token first = getToken(1);
    try {
      if (jj_2_37(2)) {
        jj_consume_token(NEW);
        tempPrimitive = PrimitiveType();
        temp = SimpleArrayInstantiationTail(tempPrimitive);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NEW:{
          jj_consume_token(NEW);
          tempReference = ClassOrInterfaceType();
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LBRACKET:{
            temp = SimpleArrayInstantiationTail(tempReference);
            break;
            }
          case LPAREN:{
            arguments = ParenthesizedExpressionList();
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case LBRACE:{
              body = BracedBody();
              break;
              }
            default:
              jj_la1[121] = jj_gen;
              ;
            }
if (body == null) {
      temp = new SimpleNamedClassInstantiation(_loc(first),
                                              tempReference,
                                              arguments);
    }
    else {
      temp = new SimpleAnonymousClassInstantiation(_loc(first),
                                               tempReference,
                                               arguments,
                                               body);
    }
            break;
            }
          default:
            jj_la1[122] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
          }
        default:
          jj_la1[123] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
{if ("" != null) return temp;}
    } catch (ParseException pe) {
_throwParseException(pe, "This cannot appear in an allocation expression!");
    }
    throw new Error("Missing return statement in function");
  }

// an array allocation either has at least one dimension expression
// or it has an initializer. can't have both.
  final public ArrayInstantiation SimpleArrayInstantiationTail(Type elementType) throws ParseException {LinkedList<Expression> dimensions = new LinkedList<Expression>();
  ArrayType arrayType = null;
  Expression exp;
  ArrayInitializer initializer;
  Token first = getToken(1);
    if (jj_2_40(2147483647)) {
      label_33:
      while (true) {
        jj_consume_token(LBRACKET);
        exp = Expression();
        jj_consume_token(RBRACKET);
if (arrayType == null) {
            arrayType = new ArrayType(_loc(elementType), elementType.getName() + "[]", elementType);
          }
          else {
            arrayType = new ArrayType(_loc(arrayType), arrayType.getName() + "[]", arrayType);
          }

          dimensions.add(exp);
        if (jj_2_38(2147483647)) {
          ;
        } else {
          break label_33;
        }
      }
      label_34:
      while (true) {
        if (jj_2_39(2)) {
          ;
        } else {
          break label_34;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
arrayType = new ArrayType(_loc(arrayType), arrayType.getName() + "[]", arrayType);
      }
{if ("" != null) return new SimpleUninitializedArrayInstantiation(_loc(elementType),
                                                        arrayType,
                                                        new DimensionExpressionList(_loc(first),
                dimensions.toArray(new Expression[dimensions.size()])));}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:{
        label_35:
        while (true) {
          jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
if (arrayType == null) {
            arrayType = new ArrayType(_loc(elementType), elementType.getName() + "[]", elementType);
          }
          else {
            arrayType = new ArrayType(_loc(arrayType), arrayType.getName() + "[]", arrayType);
          }
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LBRACKET:{
            ;
            break;
            }
          default:
            jj_la1[124] = jj_gen;
            break label_35;
          }
        }
        initializer = ArrayInitializer();
{if ("" != null) return new SimpleInitializedArrayInstantiation(_loc(elementType),
                                                    arrayType,
                                                    initializer);}
        break;
        }
      default:
        jj_la1[125] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/** Differentiates between array allocations and anonymous inner class definitions
 * @param prefix  The Primary before the new. (e.g. a.new Foo())
 */
  final public Instantiation ComplexInstantiation(Primary prefix) throws ParseException {PrimitiveType tempPrimitive;
  ReferenceType tempReference;
  Instantiation temp;
  BracedBody body = null;
  ParenthesizedExpressionList arguments;
  Token first = getToken(1);
    try {
      if (jj_2_41(2)) {
        jj_consume_token(NEW);
        tempPrimitive = PrimitiveType();
        temp = ComplexArrayInstantiationTail(prefix, tempPrimitive);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NEW:{
          jj_consume_token(NEW);
          tempReference = ClassOrInterfaceType();
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LBRACKET:{
            temp = ComplexArrayInstantiationTail(prefix, tempReference);
            break;
            }
          case LPAREN:{
            arguments = ParenthesizedExpressionList();
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case LBRACE:{
              body = BracedBody();
              break;
              }
            default:
              jj_la1[126] = jj_gen;
              ;
            }
if (body == null) {
      temp = new ComplexNamedClassInstantiation(_loc(prefix),
                                                prefix,
                                                tempReference,
                                                arguments);
    }
    else {
      temp = new ComplexAnonymousClassInstantiation(_loc(prefix),
                                                    prefix,
                                                    tempReference,
                                                    arguments,
                                                    body);
    }
            break;
            }
          default:
            jj_la1[127] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
          }
        default:
          jj_la1[128] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
{if ("" != null) return temp;}
    } catch (ParseException pe) {
_throwParseException(pe, "This cannot appear in an allocation expression!");
    }
    throw new Error("Missing return statement in function");
  }

// an array allocation either has at least one dimension expression
// or it has an initializer. can't have both.
  final public ArrayInstantiation ComplexArrayInstantiationTail(Primary prefix, Type elementType) throws ParseException {LinkedList<Expression> dimensions = new LinkedList<Expression>();
  ArrayType arrayType = null;
  Expression exp;
  ArrayInitializer initializer;
  Token first = getToken(1);
    if (jj_2_44(2147483647)) {
      label_36:
      while (true) {
        jj_consume_token(LBRACKET);
        exp = Expression();
        jj_consume_token(RBRACKET);
if (arrayType == null) {
            arrayType = new ArrayType(_loc(elementType), elementType.getName() + "[]", elementType);
          }
          else {
            arrayType = new ArrayType(_loc(arrayType), arrayType.getName() + "[]", arrayType);
          }

          dimensions.add(exp);
        if (jj_2_42(2147483647)) {
          ;
        } else {
          break label_36;
        }
      }
      label_37:
      while (true) {
        if (jj_2_43(2)) {
          ;
        } else {
          break label_37;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
arrayType = new ArrayType(_loc(arrayType), arrayType.getName() + "[]", arrayType);
      }
{if ("" != null) return new ComplexUninitializedArrayInstantiation(_loc(prefix),
                                                          prefix,
                                                        arrayType,
                                                        new DimensionExpressionList(_loc(first),
                dimensions.toArray(new Expression[dimensions.size()])));}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:{
        label_38:
        while (true) {
          jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
if (arrayType == null) {
            arrayType = new ArrayType(_loc(elementType), elementType.getName() + "[]", elementType);
          }
          else {
            arrayType = new ArrayType(_loc(arrayType), arrayType.getName() + "[]", arrayType);
          }
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LBRACKET:{
            ;
            break;
            }
          default:
            jj_la1[129] = jj_gen;
            break label_38;
          }
        }
        initializer = ArrayInitializer();
{if ("" != null) return new ComplexInitializedArrayInstantiation(_loc(prefix),
                                                    prefix,
                                                    arrayType,
                                                    initializer);}
        break;
        }
      default:
        jj_la1[130] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

//Instantiation SimpleInstantiation() :
//{ Type type; ParenthesizedExpressionList args; BracedBody body; DimensionExpressionList dimensions;
//      ArrayInitializer initializer; Token first = getToken(1); }
//{
//  <NEW> type = Type()
//    (
//      /* Lookahead to ensure at least one set of brackets follows */
//      LOOKAHEAD(<LBRACKET>) dimensions = DimensionExpressionList()
//        { return new SimpleUninitializedArrayInstantiation(_loc(first), type, dimensions); }
//
//    | initializer = ArrayInitializer()
//        { return new SimpleInitializedArrayInstantiation(_loc(first), type, initializer); }
//
//    | args = ParenthesizedExpressionList()
//        [
//          body = BracedBody() { return new SimpleAnonymousClassInstantiation(_loc(first), type, args, body); }
//        ]
//        { return new SimpleNamedClassInstantiation(_loc(first), type, args); }
//    )
//}
//
//Instantiation ComplexInstantiation(Primary prefix) :
//{ Type type; ParenthesizedExpressionList args; BracedBody body; DimensionExpressionList dimensions; ArrayInitializer initializer; }
//{
//  <NEW> type = Type()
//    (
//      /* Lookahead to ensure at least one set of brackets follows */
//      LOOKAHEAD(<LBRACKET>) dimensions = DimensionExpressionList()
//        { return new ComplexUninitializedArrayInstantiation(_loc(prefix), prefix, type, dimensions); }
//
//    | initializer = ArrayInitializer()
//        { return new ComplexInitializedArrayInstantiation(_loc(prefix), prefix, type, initializer); }
//
//    | args = ParenthesizedExpressionList()
//        [
//          body = BracedBody() { return new ComplexAnonymousClassInstantiation(_loc(prefix), prefix, type, args, body); }
//        ]
//        { return new ComplexNamedClassInstantiation(_loc(prefix), prefix, type, args); }
//    )
//}

/* TODO: This probably doesn't successfully handle overflow, especially 
 * for Integer.MIN_VALUE.  Testing of overflow should probably not
 * be the responsibility of the parser--instead, IntegerLiterals should
 * contain BigIntegers.
 */
  final public LexicalLiteral IntegerLiteral() throws ParseException {Token token; BigInteger value; int maxBitLength; Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case OCTAL_LITERAL:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DECIMAL_LITERAL:{
        token = jj_consume_token(DECIMAL_LITERAL);
value = new BigInteger(token.image, 10); maxBitLength = 31;
        break;
        }
      case OCTAL_LITERAL:{
        token = jj_consume_token(OCTAL_LITERAL);
value = new BigInteger(token.image, 8); maxBitLength = 32; /* it's always positive so use of sign bit ok */
        break;
        }
      case HEX_LITERAL:{
        token = jj_consume_token(HEX_LITERAL);
/* need to strip 0x */ value = new BigInteger(token.image.substring(2), 16); maxBitLength = 32; /* it's always positive so use of sign bit ok */
        break;
        }
      default:
        jj_la1[131] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
if (value.bitLength() <= maxBitLength) { {if ("" != null) return new IntegerLiteral(_loc(first), value.intValue());} }
        else { {if (true) throw new RuntimeException("Integer literal too big: " + token.image);} }
      break;
      }
    case LONG_DECIMAL_LITERAL:
    case LONG_HEX_LITERAL:
    case LONG_OCTAL_LITERAL:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LONG_DECIMAL_LITERAL:{
        token = jj_consume_token(LONG_DECIMAL_LITERAL);
value = new BigInteger(_stripL(token.image), 10); maxBitLength = 63;
        break;
        }
      case LONG_OCTAL_LITERAL:{
        token = jj_consume_token(LONG_OCTAL_LITERAL);
value = new BigInteger(_stripL(token.image), 8); maxBitLength = 64; /* it's always positive so use of sign bit ok */
        break;
        }
      case LONG_HEX_LITERAL:{
        token = jj_consume_token(LONG_HEX_LITERAL);
value = new BigInteger(_stripL(token.image.substring(2)), 16); maxBitLength = 64; /* it's always positive so use of sign bit ok */
        break;
        }
      default:
        jj_la1[132] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
if (value.bitLength() <= maxBitLength) { {if ("" != null) return new LongLiteral(_loc(first), value.longValue());} }
        else { {if (true) throw new RuntimeException("Long literal too big: " + token.image);} }
      break;
      }
    default:
      jj_la1[133] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public LexicalLiteral FloatLiteral() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DOUBLE_FLOATING_POINT_LITERAL:{
      t = jj_consume_token(DOUBLE_FLOATING_POINT_LITERAL);
try {
          double value = Double.parseDouble(t.image);
          {if ("" != null) return new DoubleLiteral(_loc(t), value);}
        }
        catch (NumberFormatException e) {
          {if (true) throw new RuntimeException("Invalid double constant: " + t.image + ". Exception: " + e);}
        }
      break;
      }
    case FLOATING_POINT_LITERAL:{
      t = jj_consume_token(FLOATING_POINT_LITERAL);
try {
          float value = Float.parseFloat(t.image);
          {if ("" != null) return new FloatLiteral(_loc(t), value);}
        }
        catch (NumberFormatException e) {
          {if (true) throw new RuntimeException("Invalid float constant: " + t.image + ". Exception: " + e);}
        }
      break;
      }
    default:
      jj_la1[134] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public BooleanLiteral BooleanLiteral() throws ParseException {Token first = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TRUE:{
      jj_consume_token(TRUE);
{if ("" != null) return new BooleanLiteral(_loc(first), true);}
      break;
      }
    case FALSE:{
      jj_consume_token(FALSE);
{if ("" != null) return new BooleanLiteral(_loc(first), false);}
      break;
      }
    default:
      jj_la1[135] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
 * Misc helpers
 */
  final public 

Word Word() throws ParseException {Token text; Token first = getToken(1);
    text = jj_consume_token(IDENTIFIER);
{if ("" != null) return new Word(_loc(first), text.image);}
    throw new Error("Missing return statement in function");
  }

  final public Token RightShiftOp() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case RSSHIFT1:{
      t = jj_consume_token(RSSHIFT1);
      jj_consume_token(RSSHIFT2);
{if ("" != null) return t;}
      break;
      }
    case RUSHIFT1:{
      t = jj_consume_token(RUSHIFT1);
      jj_consume_token(RUSHIFT2);
      jj_consume_token(RUSHIFT3);
{if ("" != null) return t;}
      break;
      }
    default:
      jj_la1[136] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ParenthesizedExpressionList ParenthesizedExpressionList() throws ParseException {ExpressionList list; Token first = getToken(1);
    jj_consume_token(LPAREN);
    list = UnparenthesizedExpressionList();
    jj_consume_token(RPAREN);
{if ("" != null) return new ParenthesizedExpressionList(_loc(first), list.getExpressions());}
    throw new Error("Missing return statement in function");
  }

  final public UnparenthesizedExpressionList UnparenthesizedExpressionList() throws ParseException {Vector<Expression> list = new Vector<Expression>(); Expression expression; Token first = getToken(1);
    expression = Expression();
list.add(expression);
    label_39:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[137] = jj_gen;
        break label_39;
      }
      jj_consume_token(COMMA);
      expression = Expression();
list.add(expression);
    }
/* If the list contains only an EmptyExpression, it's actually an empty list. */
      if (list.size() == 1 && list.get(0) instanceof EmptyExpression) {
        {if ("" != null) return new UnparenthesizedExpressionList(_loc(first), new Expression[0]);}
      }
      else {
        {if ("" != null) return new UnparenthesizedExpressionList(_loc(first), list.toArray(new Expression[list.size()]));}
      }
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_3R_190()
 {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_158()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(63)) {
    jj_scanpos = xsp;
    if (jj_3R_317()) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_318()) return true;
    }
    if (jj_3R_88()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_319()) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_320()) return true;
    }
    return false;
  }

  private boolean jj_3R_189()
 {
    if (jj_scan_token(WHILE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_315()) return true;
    }
    if (jj_3R_88()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_316()) return true;
    }
    if (jj_3R_158()) return true;
    return false;
  }

  private boolean jj_3R_293()
 {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_313()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_288()
 {
    if (jj_3R_270()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_293()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_312()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_287()
 {
    if (jj_3R_286()) return true;
    return false;
  }

  private boolean jj_3R_314()
 {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_158()) return true;
    return false;
  }

  private boolean jj_3R_281()
 {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_49()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_287()) {
    jj_scanpos = xsp;
    if (jj_3R_288()) return true;
    }
    return false;
  }

  private boolean jj_3_41()
 {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_48()) return true;
    if (jj_3R_286()) return true;
    return false;
  }

  private boolean jj_3R_188()
 {
    if (jj_scan_token(IF)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_312()) return true;
    }
    if (jj_3R_88()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_313()) return true;
    }
    if (jj_3R_158()) return true;
    xsp = jj_scanpos;
    if (jj_3R_314()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_271()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_41()) {
    jj_scanpos = xsp;
    if (jj_3R_281()) return true;
    }
    return false;
  }

  private boolean jj_3R_56()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_347()
 {
    if (jj_scan_token(_DEFAULT)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_309()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_43()
 {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_56()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_308()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_346()
 {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_88()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_337()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_346()) {
    jj_scanpos = xsp;
    if (jj_3R_347()) return true;
    }
    return false;
  }

  private boolean jj_3R_311()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_290()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_310()
 {
    if (jj_3R_337()) return true;
    return false;
  }

  private boolean jj_3R_283()
 {
    Token xsp;
    if (jj_3R_290()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_290()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_187()
 {
    if (jj_scan_token(SWITCH)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_308()) return true;
    }
    if (jj_3R_88()) return true;
    if (jj_scan_token(RPAREN)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_3R_309()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_310()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_3R_311()) return true;
    }
    return false;
  }

  private boolean jj_3_39()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3_38()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_198()
 {
    if (jj_3R_88()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_60()
 {
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3_40()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_289()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_88()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_58()
 {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_282()
 {
    Token xsp;
    if (jj_3R_289()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_289()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_39()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_277()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_282()) {
    jj_scanpos = xsp;
    if (jj_3R_283()) return true;
    }
    return false;
  }

  private boolean jj_3R_51()
 {
    if (jj_3R_42()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_158()) return true;
    return false;
  }

  private boolean jj_3_22()
 {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_46()
 {
    if (jj_3R_43()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_61()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) return true;
    }
    return false;
  }

  private boolean jj_3R_181()
 {
    if (jj_3R_199()) return true;
    return false;
  }

  private boolean jj_3R_180()
 {
    if (jj_3R_198()) return true;
    return false;
  }

  private boolean jj_3R_179()
 {
    if (jj_3R_197()) return true;
    return false;
  }

  private boolean jj_3R_59()
 {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_178()
 {
    if (jj_3R_196()) return true;
    return false;
  }

  private boolean jj_3R_45()
 {
    if (jj_3R_43()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_59()) jj_scanpos = xsp;
    if (jj_3R_55()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    xsp = jj_scanpos;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) return true;
    }
    return false;
  }

  private boolean jj_3R_177()
 {
    if (jj_3R_195()) return true;
    return false;
  }

  private boolean jj_3R_176()
 {
    if (jj_3R_194()) return true;
    return false;
  }

  private boolean jj_3R_284()
 {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_175()
 {
    if (jj_3R_193()) return true;
    return false;
  }

  private boolean jj_3R_174()
 {
    if (jj_3R_192()) return true;
    return false;
  }

  private boolean jj_3R_279()
 {
    if (jj_3R_270()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_284()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_173()
 {
    if (jj_3R_191()) return true;
    return false;
  }

  private boolean jj_3R_278()
 {
    if (jj_3R_277()) return true;
    return false;
  }

  private boolean jj_3R_172()
 {
    if (jj_3R_190()) return true;
    return false;
  }

  private boolean jj_3R_171()
 {
    if (jj_3R_189()) return true;
    return false;
  }

  private boolean jj_3_20()
 {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  private boolean jj_3R_170()
 {
    if (jj_3R_188()) return true;
    return false;
  }

  private boolean jj_3R_260()
 {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_49()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_278()) {
    jj_scanpos = xsp;
    if (jj_3R_279()) return true;
    }
    return false;
  }

  private boolean jj_3R_169()
 {
    if (jj_3R_187()) return true;
    return false;
  }

  private boolean jj_3_21()
 {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3_37()
 {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_48()) return true;
    if (jj_3R_277()) return true;
    return false;
  }

  private boolean jj_3R_168()
 {
    if (jj_3R_58()) return true;
    return false;
  }

  private boolean jj_3R_257()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_37()) {
    jj_scanpos = xsp;
    if (jj_3R_260()) return true;
    }
    return false;
  }

  private boolean jj_3R_158()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) {
    jj_scanpos = xsp;
    if (jj_3R_171()) {
    jj_scanpos = xsp;
    if (jj_3R_172()) {
    jj_scanpos = xsp;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3R_175()) {
    jj_scanpos = xsp;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) {
    jj_scanpos = xsp;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) {
    jj_scanpos = xsp;
    if (jj_3R_180()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_109()
 {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_105()
 {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_104()
 {
    if (jj_3R_114()) return true;
    return false;
  }

  private boolean jj_3R_103()
 {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_184()
 {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_102()
 {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_101()
 {
    if (jj_3R_113()) return true;
    return false;
  }

  private boolean jj_3R_41()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_91()
 {
    if (jj_3R_108()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_109()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_100()
 {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3_2()
 {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_41()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }

  private boolean jj_3R_86()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_276()
 {
    if (jj_3R_270()) return true;
    return false;
  }

  private boolean jj_3R_40()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3_36()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_35()
 {
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3_1()
 {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_40()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_160()
 {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_269()
 {
    if (jj_3R_42()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_276()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_93()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) {
    jj_scanpos = xsp;
    if (jj_scan_token(117)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_275()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_274()
 {
    if (jj_3R_270()) return true;
    return false;
  }

  private boolean jj_3R_273()
 {
    return false;
  }

  private boolean jj_3R_268()
 {
    if (jj_scan_token(SUPER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_273()) {
    jj_scanpos = xsp;
    if (jj_3R_274()) {
    jj_scanpos = xsp;
    if (jj_3R_275()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_272()
 {
    if (jj_3R_270()) return true;
    return false;
  }

  private boolean jj_3R_92()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_91()) return true;
    return false;
  }

  private boolean jj_3R_267()
 {
    if (jj_scan_token(THIS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_272()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_77()
 {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_91()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_92()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_93()) return true;
    return false;
  }

  private boolean jj_3R_266()
 {
    if (jj_3R_271()) return true;
    return false;
  }

  private boolean jj_3_19()
 {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_89()
 {
    if (jj_3R_86()) return true;
    return false;
  }

  private boolean jj_3R_256()
 {
    if (jj_scan_token(DOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_266()) {
    jj_scanpos = xsp;
    if (jj_3R_267()) {
    jj_scanpos = xsp;
    if (jj_3R_268()) {
    jj_scanpos = xsp;
    if (jj_3R_269()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_247()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_255()) {
    jj_scanpos = xsp;
    if (jj_3R_256()) return true;
    }
    return false;
  }

  private boolean jj_3R_255()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_88()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3_33()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3_32()
 {
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  private boolean jj_3R_265()
 {
    if (jj_3R_270()) return true;
    return false;
  }

  private boolean jj_3_18()
 {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_183()
 {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_161()
 {
    if (jj_scan_token(COMMA)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_183()) {
    jj_scanpos = xsp;
    if (jj_3R_184()) return true;
    }
    return false;
  }

  private boolean jj_3R_254()
 {
    if (jj_3R_42()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_265()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_264()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_263()
 {
    if (jj_3R_270()) return true;
    return false;
  }

  private boolean jj_3R_262()
 {
    return false;
  }

  private boolean jj_3R_159()
 {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3_34()
 {
    if (jj_3R_55()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_84()
 {
    if (jj_scan_token(LT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_161()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_93()) return true;
    return false;
  }

  private boolean jj_3R_253()
 {
    if (jj_scan_token(SUPER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_262()) {
    jj_scanpos = xsp;
    if (jj_3R_263()) {
    jj_scanpos = xsp;
    if (jj_3R_264()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_261()
 {
    if (jj_3R_270()) return true;
    return false;
  }

  private boolean jj_3_17()
 {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  private boolean jj_3R_252()
 {
    if (jj_scan_token(THIS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_261()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_251()
 {
    if (jj_3R_55()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_250()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_88()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_249()
 {
    if (jj_3R_257()) return true;
    return false;
  }

  private boolean jj_3R_144()
 {
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3R_246()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) {
    jj_scanpos = xsp;
    if (jj_3R_250()) {
    jj_scanpos = xsp;
    if (jj_3R_251()) {
    jj_scanpos = xsp;
    if (jj_3R_252()) {
    jj_scanpos = xsp;
    if (jj_3R_253()) {
    jj_scanpos = xsp;
    if (jj_3R_254()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_248()
 {
    if (jj_3R_86()) return true;
    return false;
  }

  private boolean jj_3_15()
 {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  private boolean jj_3R_242()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_246()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_16()
 {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_144()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_65()
 {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_243()
 {
    if (jj_3R_247()) return true;
    return false;
  }

  private boolean jj_3R_64()
 {
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3R_240()
 {
    if (jj_3R_242()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_243()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_97()
 {
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_49()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_64()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_16()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_245()
 {
    if (jj_scan_token(DECR)) return true;
    return false;
  }

  private boolean jj_3R_241()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_244()) {
    jj_scanpos = xsp;
    if (jj_3R_245()) return true;
    }
    return false;
  }

  private boolean jj_3R_244()
 {
    if (jj_scan_token(INCR)) return true;
    return false;
  }

  private boolean jj_3_31()
 {
    if (jj_3R_48()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_239()
 {
    if (jj_3R_240()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_241()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_259()
 {
    if (jj_3R_47()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_233()) return true;
    return false;
  }

  private boolean jj_3R_258()
 {
    if (jj_3R_48()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_221()) return true;
    return false;
  }

  private boolean jj_3R_108()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_30()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_47()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_238()
 {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_258()) {
    jj_scanpos = xsp;
    if (jj_3R_259()) return true;
    }
    return false;
  }

  private boolean jj_3R_73()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_47()) return true;
    if (jj_scan_token(RPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_3R_89()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_72()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_47()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3_29()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_54()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_29()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_66()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3_28()
 {
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3_14()
 {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_50()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_14()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) return true;
    }
    if (jj_3R_66()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_66()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_237()
 {
    if (jj_3R_239()) return true;
    return false;
  }

  private boolean jj_3R_236()
 {
    if (jj_3R_238()) return true;
    return false;
  }

  private boolean jj_3R_235()
 {
    if (jj_scan_token(BANG)) return true;
    if (jj_3R_221()) return true;
    return false;
  }

  private boolean jj_3R_233()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) {
    jj_scanpos = xsp;
    if (jj_3R_236()) {
    jj_scanpos = xsp;
    if (jj_3R_237()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_234()
 {
    if (jj_scan_token(TILDE)) return true;
    if (jj_3R_221()) return true;
    return false;
  }

  private boolean jj_3_13()
 {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_82()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_13()) {
    jj_scanpos = xsp;
    if (jj_3R_97()) return true;
    }
    return false;
  }

  private boolean jj_3R_229()
 {
    if (jj_3R_233()) return true;
    return false;
  }

  private boolean jj_3R_62()
 {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_228()
 {
    if (jj_scan_token(MINUS)) return true;
    if (jj_3R_221()) return true;
    return false;
  }

  private boolean jj_3R_227()
 {
    if (jj_scan_token(PLUS)) return true;
    if (jj_3R_221()) return true;
    return false;
  }

  private boolean jj_3R_226()
 {
    if (jj_scan_token(DECR)) return true;
    if (jj_3R_221()) return true;
    return false;
  }

  private boolean jj_3R_221()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_225()) {
    jj_scanpos = xsp;
    if (jj_3R_226()) {
    jj_scanpos = xsp;
    if (jj_3R_227()) {
    jj_scanpos = xsp;
    if (jj_3R_228()) {
    jj_scanpos = xsp;
    if (jj_3R_229()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_225()
 {
    if (jj_scan_token(INCR)) return true;
    if (jj_3R_221()) return true;
    return false;
  }

  private boolean jj_3R_83()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_232()
 {
    if (jj_scan_token(REM)) return true;
    if (jj_3R_221()) return true;
    return false;
  }

  private boolean jj_3R_231()
 {
    if (jj_scan_token(SLASH)) return true;
    if (jj_3R_221()) return true;
    return false;
  }

  private boolean jj_3R_222()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_230()) {
    jj_scanpos = xsp;
    if (jj_3R_231()) {
    jj_scanpos = xsp;
    if (jj_3R_232()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_230()
 {
    if (jj_scan_token(STAR)) return true;
    if (jj_3R_221()) return true;
    return false;
  }

  private boolean jj_3R_48()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(14)) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_217()
 {
    if (jj_3R_221()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_222()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_12()
 {
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_224()
 {
    if (jj_scan_token(MINUS)) return true;
    if (jj_3R_217()) return true;
    return false;
  }

  private boolean jj_3R_218()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) return true;
    }
    return false;
  }

  private boolean jj_3R_223()
 {
    if (jj_scan_token(PLUS)) return true;
    if (jj_3R_217()) return true;
    return false;
  }

  private boolean jj_3R_210()
 {
    if (jj_3R_217()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_218()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_63()
 {
    if (jj_scan_token(LBRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_3R_83()) return true;
    }
    return false;
  }

  private boolean jj_3_11()
 {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_47()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_63()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_220()
 {
    if (jj_3R_85()) return true;
    if (jj_3R_210()) return true;
    return false;
  }

  private boolean jj_3R_211()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) return true;
    }
    return false;
  }

  private boolean jj_3R_219()
 {
    if (jj_scan_token(LSHIFT)) return true;
    if (jj_3R_210()) return true;
    return false;
  }

  private boolean jj_3R_206()
 {
    if (jj_3R_210()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_211()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_216()
 {
    if (jj_scan_token(INSTANCEOF)) return true;
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_215()
 {
    if (jj_scan_token(GE)) return true;
    if (jj_3R_206()) return true;
    return false;
  }

  private boolean jj_3R_214()
 {
    if (jj_scan_token(GT)) return true;
    if (jj_3R_206()) return true;
    return false;
  }

  private boolean jj_3R_213()
 {
    if (jj_scan_token(LE)) return true;
    if (jj_3R_206()) return true;
    return false;
  }

  private boolean jj_3R_207()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) {
    jj_scanpos = xsp;
    if (jj_3R_214()) {
    jj_scanpos = xsp;
    if (jj_3R_215()) {
    jj_scanpos = xsp;
    if (jj_3R_216()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_212()
 {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_206()) return true;
    return false;
  }

  private boolean jj_3R_57()
 {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_44()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_57()) jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    return false;
  }

  private boolean jj_3R_204()
 {
    if (jj_3R_206()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_207()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_209()
 {
    if (jj_scan_token(NE)) return true;
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_205()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) return true;
    }
    return false;
  }

  private boolean jj_3R_208()
 {
    if (jj_scan_token(EQ)) return true;
    if (jj_3R_204()) return true;
    return false;
  }

  private boolean jj_3R_202()
 {
    if (jj_3R_204()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_205()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_203()
 {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_202()) return true;
    return false;
  }

  private boolean jj_3R_299()
 {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_305()) return true;
    return false;
  }

  private boolean jj_3R_200()
 {
    if (jj_3R_202()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_203()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_201()
 {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_200()) return true;
    return false;
  }

  private boolean jj_3R_156()
 {
    if (jj_3R_43()) return true;
    if (jj_3R_42()) return true;
    if (jj_3R_61()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_299()) jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_185()
 {
    if (jj_3R_200()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_201()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_186()
 {
    if (jj_scan_token(BIT_OR)) return true;
    if (jj_3R_185()) return true;
    return false;
  }

  private boolean jj_3R_162()
 {
    if (jj_3R_185()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_186()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_163()
 {
    if (jj_scan_token(SC_AND)) return true;
    if (jj_3R_162()) return true;
    return false;
  }

  private boolean jj_3R_94()
 {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  private boolean jj_3R_69()
 {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_151()
 {
    if (jj_3R_162()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_163()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_78()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_94()) jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_81()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_152()
 {
    if (jj_scan_token(SC_OR)) return true;
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_67()
 {
    if (jj_3R_85()) return true;
    return false;
  }

  private boolean jj_3R_124()
 {
    if (jj_3R_151()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_152()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_79()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_125()
 {
    if (jj_scan_token(HOOK)) return true;
    if (jj_3R_88()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_115()) return true;
    return false;
  }

  private boolean jj_3R_96()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3R_80()
 {
    if (jj_3R_78()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_96()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_115()
 {
    if (jj_3R_124()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_125()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_61()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_79()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_80()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_81()) return true;
    }
    return false;
  }

  private boolean jj_3R_137()
 {
    if (jj_scan_token(XORASSIGN)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_136()
 {
    if (jj_scan_token(ORASSIGN)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_135()
 {
    if (jj_scan_token(ANDASSIGN)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_134()
 {
    if (jj_scan_token(RUNSIGNEDSHIFTASSIGN)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_133()
 {
    if (jj_scan_token(RSIGNEDSHIFTASSIGN)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_132()
 {
    if (jj_scan_token(LSHIFTASSIGN)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_131()
 {
    if (jj_scan_token(REMASSIGN)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_130()
 {
    if (jj_scan_token(SLASHASSIGN)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_129()
 {
    if (jj_scan_token(STARASSIGN)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_128()
 {
    if (jj_scan_token(MINUSASSIGN)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_127()
 {
    if (jj_scan_token(PLUSASSIGN)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_75()
 {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_126()
 {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_116()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_126()) {
    jj_scanpos = xsp;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) {
    jj_scanpos = xsp;
    if (jj_3R_134()) {
    jj_scanpos = xsp;
    if (jj_3R_135()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_74()
 {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  private boolean jj_3R_55()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) return true;
    }
    return false;
  }

  private boolean jj_3R_106()
 {
    if (jj_3R_115()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_116()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_27()
 {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_307()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_305()
 {
    if (jj_3R_49()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_307()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_68()
 {
    if (jj_3R_86()) return true;
    return false;
  }

  private boolean jj_3R_88()
 {
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3R_296()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_182()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_157()
 {
    if (jj_3R_43()) return true;
    if (jj_3R_167()) return true;
    return false;
  }

  private boolean jj_3R_52()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(125)) {
    jj_scanpos = xsp;
    if (jj_scan_token(126)) {
    jj_scanpos = xsp;
    if (jj_scan_token(127)) {
    jj_scanpos = xsp;
    if (jj_scan_token(128)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(123)) {
    jj_scanpos = xsp;
    if (jj_scan_token(124)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) {
    jj_scanpos = xsp;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(94)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(110)) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) {
    jj_scanpos = xsp;
    if (jj_scan_token(103)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) {
    jj_scanpos = xsp;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) {
    jj_scanpos = xsp;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_3R_69()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_26()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_87()
 {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_53()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_26()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(85)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_3R_182()) return true;
    }
    return false;
  }

  private boolean jj_3R_298()
 {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_305()) return true;
    return false;
  }

  private boolean jj_3R_71()
 {
    if (jj_3R_88()) return true;
    return false;
  }

  private boolean jj_3_10()
 {
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_70()
 {
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_53()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    }
    return false;
  }

  private boolean jj_3R_297()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_345()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_285()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_88()) return true;
    return false;
  }

  private boolean jj_3R_280()
 {
    if (jj_3R_88()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_285()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_166()
 {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_111()
 {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_155()
 {
    if (jj_3R_43()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_166()) jj_scanpos = xsp;
    if (jj_3R_55()) return true;
    if (jj_3R_42()) return true;
    if (jj_3R_61()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_297()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_298()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_110()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_270()
 {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_280()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_95()
 {
    if (jj_3R_42()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_110()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_111()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_99()
 {
    if (jj_scan_token(RUSHIFT1)) return true;
    if (jj_scan_token(RUSHIFT2)) return true;
    if (jj_scan_token(RUSHIFT3)) return true;
    return false;
  }

  private boolean jj_3_9()
 {
    if (jj_3R_43()) return true;
    if (jj_3R_47()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_8()
 {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3_7()
 {
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_98()
 {
    if (jj_scan_token(RSSHIFT1)) return true;
    if (jj_scan_token(RSSHIFT2)) return true;
    return false;
  }

  private boolean jj_3R_85()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) return true;
    }
    return false;
  }

  private boolean jj_3_5()
 {
    if (jj_3R_43()) return true;
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_3R_43()) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_42()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_143()
 {
    if (jj_3R_158()) return true;
    return false;
  }

  private boolean jj_3R_142()
 {
    if (jj_3R_157()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_296()) return true;
    }
    return false;
  }

  private boolean jj_3R_141()
 {
    if (jj_3R_156()) return true;
    return false;
  }

  private boolean jj_3R_140()
 {
    if (jj_3R_155()) return true;
    return false;
  }

  private boolean jj_3_6()
 {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_139()
 {
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_138()
 {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_123()
 {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_122()
 {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_114()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) return true;
    }
    return false;
  }

  private boolean jj_3R_117()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_138()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) {
    jj_scanpos = xsp;
    if (jj_3_6()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_306()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_95()) return true;
    return false;
  }

  private boolean jj_3R_107()
 {
    if (jj_3R_117()) return true;
    return false;
  }

  private boolean jj_3R_342()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_90()
 {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_107()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_121()
 {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_344()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_167()
 {
    if (jj_3R_47()) return true;
    if (jj_3R_95()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_306()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_76()
 {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_90()) return true;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_120()
 {
    if (jj_scan_token(DOUBLE_FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_113()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) return true;
    }
    return false;
  }

  private boolean jj_3R_199()
 {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_150()
 {
    if (jj_scan_token(LONG_HEX_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_149()
 {
    if (jj_scan_token(LONG_OCTAL_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_154()
 {
    if (jj_3R_43()) return true;
    if (jj_3R_165()) return true;
    return false;
  }

  private boolean jj_3R_148()
 {
    if (jj_scan_token(LONG_DECIMAL_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_119()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_333()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_147()
 {
    if (jj_scan_token(HEX_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_146()
 {
    if (jj_scan_token(OCTAL_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_336()
 {
    if (jj_scan_token(FINALLY)) return true;
    if (jj_3R_58()) return true;
    return false;
  }

  private boolean jj_3R_334()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_145()
 {
    if (jj_scan_token(DECIMAL_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_118()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_112()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_118()) {
    jj_scanpos = xsp;
    if (jj_3R_119()) return true;
    }
    return false;
  }

  private boolean jj_3R_335()
 {
    if (jj_scan_token(CATCH)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_344()) return true;
    }
    if (jj_3R_78()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_345()) return true;
    }
    if (jj_3R_58()) return true;
    return false;
  }

  private boolean jj_3R_304()
 {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_305()) return true;
    return false;
  }

  private boolean jj_3R_303()
 {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_197()
 {
    if (jj_scan_token(TRY)) return true;
    if (jj_3R_58()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_335()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_336()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_165()
 {
    if (jj_scan_token(INTERFACE)) return true;
    if (jj_3R_42()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_303()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_304()) jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_330()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_196()
 {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_334()) return true;
    }
    if (jj_3R_88()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_58()) return true;
    return false;
  }

  private boolean jj_3R_343()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3_25()
 {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_195()
 {
    if (jj_scan_token(THROW)) return true;
    if (jj_3R_88()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_333()) return true;
    }
    return false;
  }

  private boolean jj_3R_328()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_332()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_343()) return true;
    }
    return false;
  }

  private boolean jj_3R_331()
 {
    if (jj_3R_88()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_342()) return true;
    }
    return false;
  }

  private boolean jj_3R_318()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_194()
 {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_331()) {
    jj_scanpos = xsp;
    if (jj_3R_332()) return true;
    }
    return false;
  }

  private boolean jj_3R_329()
 {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_316()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_193()
 {
    if (jj_scan_token(CONTINUE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_329()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_330()) return true;
    }
    return false;
  }

  private boolean jj_3R_295()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_327()
 {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_292()
 {
    Token xsp;
    if (jj_3R_295()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_295()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_320()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_153()
 {
    if (jj_3R_43()) return true;
    if (jj_3R_164()) return true;
    return false;
  }

  private boolean jj_3_24()
 {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_192()
 {
    if (jj_scan_token(BREAK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_327()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_328()) return true;
    }
    return false;
  }

  private boolean jj_3_43()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_317()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3_23()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(29)) jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_42()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_341()
 {
    return false;
  }

  private boolean jj_3R_340()
 {
    if (jj_3R_88()) return true;
    return false;
  }

  private boolean jj_3R_324()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_340()) {
    jj_scanpos = xsp;
    if (jj_3R_341()) return true;
    }
    return false;
  }

  private boolean jj_3R_326()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_325()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_302()
 {
    if (jj_scan_token(IMPLEMENTS)) return true;
    if (jj_3R_305()) return true;
    return false;
  }

  private boolean jj_3R_323()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_301()
 {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_300()
 {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3_44()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_339()
 {
    if (jj_3R_280()) return true;
    return false;
  }

  private boolean jj_3R_294()
 {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_88()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_338()
 {
    if (jj_3R_157()) return true;
    return false;
  }

  private boolean jj_3R_164()
 {
    if (jj_scan_token(CLASS)) return true;
    if (jj_3R_42()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_300()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_301()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_302()) jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_321()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_322()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_338()) {
    jj_scanpos = xsp;
    if (jj_3R_339()) return true;
    }
    return false;
  }

  private boolean jj_3R_291()
 {
    Token xsp;
    if (jj_3R_294()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_294()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_43()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_319()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_286()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_291()) {
    jj_scanpos = xsp;
    if (jj_3R_292()) return true;
    }
    return false;
  }

  private boolean jj_3R_315()
 {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_191()
 {
    if (jj_scan_token(FOR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_3R_321()) return true;
    }
    if (jj_3R_322()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_323()) return true;
    }
    if (jj_3R_324()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_3R_325()) return true;
    }
    if (jj_3R_280()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_326()) return true;
    }
    if (jj_3R_158()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public JExprParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[138];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x20102000,0x0,0xa2094000,0x0,0x20002000,0x20002000,0x0,0x0,0x0,0x0,0x20002000,0x20002000,0x0,0x8000000,0x0,0x0,0x8000000,0xb359e000,0x0,0x9349c000,0x0,0x0,0x0,0x0,0x82094000,0x0,0x0,0xa2094000,0x0,0x20000000,0x0,0x0,0x0,0x0,0x82094000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x1408000,0x0,0x0,0x0,0x820000,0x0,0x820000,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x92094000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x82094000,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x92094000,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1000,0x10,0x444ce280,0x0,0x20140,0x2000000,0x4408e000,0x4408e000,0x0,0x0,0x0,0x0,0x444ce200,0x444ce200,0x0,0x0,0x8,0x0,0x0,0xfdffefe5,0x0,0xb9f30d65,0x0,0x2000000,0x0,0x0,0x20020140,0x0,0x0,0x20140,0x0,0x0,0x2000000,0x80000,0x0,0x0,0x20140,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x91610005,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8920d60,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8900c00,0x0,0x20140,0x0,0x0,0x0,0x0,0x0,0x8000c00,0x900000,0x28920d40,0x0,0x0,0x900400,0x0,0x8000800,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x2000000,0xa000,0x10000,0x0,0x0,0xb40000,0x100000,0x100000,0x400000,0x0,0x0,0x2000000,0x0,0x0,0x2000000,0x0,0xdfd566ff,0x100000,0xdfd566ff,0x2000000,0x0,0x100000,0x200000,0x2000,0x4000,0x200000,0x2000,0x8000,0x0,0x0,0x0,0x2000,0x80000,0x0,0x2000,0x2000,0x40000,0x2000,0x200000,0x2000,0x200000,0x1000000,0x0,0x0,0x100000,0x4000,0x10000,0x0,0x20000,0x0,0x4000,0x8000,0x0,0x4000,0x8000,0x0,0x4000,0x8000,0x100000,0x4000,0x100000,0x100000,0x8000,0x2000,0x100000,0x2000,0x100000,0x100000,0x100000,0x100000,0x4000,0x0,0x4000,0x8000,0x0,0x200000,0x40000,0x800000,0x10000,0x200000,0x20000,0xdf8066ff,0x800000,0x800000,0x10000000,0x0,0x0,0x0,0x0,0x0,0x40000000,0x40000000,0x83000000,0x83000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000000,0xc0066ff,0x4000,0x2000,0x0,0x0,0x440000,0x4000,0x4000,0x46ff,0x2000,0x66ff,0x4000,0x4000,0x2000,0x440000,0x6ff,0x10000,0x44000,0x0,0x40000,0x40000,0x10000,0x44000,0x0,0x40000,0x40000,0x7,0x38,0x3f,0xc0,0x0,0x0,0x200000,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffca7fff,0x0,0xffca7fff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3e0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffca7fff,0xffc00000,0xffc00000,0x0,0x4,0x8,0x800,0x1000,0x400,0x2,0x2,0x1,0x1,0xa4000,0xa4000,0xc0,0xc0,0x2300,0x2300,0xf0,0x0,0x0,0x0,0x0,0x30,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa0000,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[44];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public JExprParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public JExprParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new JExprParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 138; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 138; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public JExprParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new JExprParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 138; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 138; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public JExprParser(JExprParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 138; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(JExprParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 138; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[130];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 138; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 130; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 44; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

//class VariableDeclarator {
//  public Word identifier;
//  public Type type;
//  public VariableInitializerI initializer = JExprParser.NO_VARIABLE_INITIALIZER;
//}

class UnmodifiedClassDef {
  public Word name;
  // provide defaults here for things that can be unspecified
  public TypeParameter[] typeParameters = new TypeParameter[0];
  public ReferenceType superclass = JExprParser.NO_TYPE;
  public ReferenceType[] interfaces = new ReferenceType[0];
  public BracedBody body;
}

class UnmodifiedInterfaceDef {
  public Word name;
  public TypeParameter[] typeParameters = new TypeParameter[0];
  public ReferenceType[] superinterfaces = new ReferenceType[0];
  public BracedBody body;
//  public AbstractMethodDef[] methods = new AbstractMethodDef[0];
//  public FinalStaticFieldDef[] fields = new FinalStaticFieldDef[0];
//  public StaticInnerDefI[] inners = new StaticInnerDefI[0];
}
