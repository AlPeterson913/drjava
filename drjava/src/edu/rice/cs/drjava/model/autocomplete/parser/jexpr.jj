/**
 * Grammar for J-expressions.
 * Adapted from Java1.0.2LS.jj from the JavaCC distribution. 
 */

options {
  JAVA_UNICODE_ESCAPE = true;
  LOOKAHEAD = 1;
  //OUTPUT_DIRECTORY = "parser";
  DEBUG_PARSER = false;
  STATIC = false;
}

PARSER_BEGIN(ACParser)

/*BEGIN_COPYRIGHT_BLOCK
 *
 * This file is part of DrJava.  Download the current version of this project:
 * http://sourceforge.net/projects/drjava/ or http://www.drjava.org/
 *
 * DrJava Open Source License
 * 
 * Copyright (C) 2001-2003 JavaPLT group at Rice University (javaplt@rice.edu)
 * All rights reserved.
 *
 * Developed by:   Java Programming Languages Team
 *                 Rice University
 *                 http://www.cs.rice.edu/~javaplt/
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the "Software"),
 * to deal with the Software without restriction, including without 
 * limitation the rights to use, copy, modify, merge, publish, distribute, 
 * sublicense, and/or sell copies of the Software, and to permit persons to 
 * whom the Software is furnished to do so, subject to the following 
 * conditions:
 * 
 *     - Redistributions of source code must retain the above copyright 
 *       notice, this list of conditions and the following disclaimers.
 *     - Redistributions in binary form must reproduce the above copyright 
 *       notice, this list of conditions and the following disclaimers in the
 *       documentation and/or other materials provided with the distribution.
 *     - Neither the names of DrJava, the JavaPLT, Rice University, nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this Software without specific prior written permission.
 *     - Products derived from this software may not be called "DrJava" nor
 *       use the term "DrJava" as part of their names without prior written
 *       permission from the JavaPLT group.  For permission, write to
 *       javaplt@rice.edu.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
 * THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR 
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
 * OTHER DEALINGS WITH THE SOFTWARE.
 * 
END_COPYRIGHT_BLOCK*/
  
package edu.rice.cs.drjava.model.autocomplete.parser;



import java.io.File;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.StringReader;
import java.util.ListIterator;
import java.util.LinkedList;
import java.math.BigInteger;

//import edu.rice.cs.javaast.*;
//import edu.rice.cs.javaast.Visibility;
//import edu.rice.cs.javaast.ClassModifier;
//import edu.rice.cs.javaast.SourceInfo;
//import edu.rice.cs.javaast.CharConverter;
import edu.rice.cs.javalanglevels.*;
import edu.rice.cs.javalanglevels.tree.*;

public class ACParser {
  public static final SourceInfo NO_SOURCE_INFO = new SourceInfo(null, -1, -1, -1, -1);

  public static final ClassOrInterfaceType NO_TYPE = new ClassOrInterfaceType(NO_SOURCE_INFO, "Object", new Type[0]);
  public static final VariableInitializerI NO_VARIABLE_INITIALIZER = new NoVariableInitializer(NO_SOURCE_INFO);
  public static final EmptyForInit EMPTY_FOR_INIT = new EmptyForInit(NO_SOURCE_INFO);
  public static final EmptyForUpdate EMPTY_FOR_UPDATE = new EmptyForUpdate(NO_SOURCE_INFO);
  public static final EmptyForCondition EMPTY_FOR_CONDITION = new EmptyForCondition(NO_SOURCE_INFO);
  public static final NoAllocationQualifier NO_ALLOCATION_QUALIFIER = new NoAllocationQualifier(NO_SOURCE_INFO);
  public static final NoAllocationExpression NO_ALLOCATION_EXPRESSION= new NoAllocationExpression(NO_SOURCE_INFO);
  private boolean _inInterface;

//  private Vector/*<ParseException>*/ _errors;
  private static File _currentFile;
  public static void main(String args[]) {
    ACParser parser;
//    _errors = new Vector/*<ParseException>*/();
    if (args.length == 0) {
      System.out.println("JExpression Parser Version 1.0.2:  Reading from standard input . . .");
      parser = new ACParser(System.in);
    } else if (args.length == 1) {
      System.out.println("JExpression Parser Version 1.0.2:  Reading from file " + args[0] + " . . .");
      try {
        _currentFile = new File(args[0]);
        parser = new ACParser(new java.io.FileInputStream(_currentFile));
      } catch (java.io.FileNotFoundException e) {
        System.out.println("JExpression Parser Version 1.0.2:  File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("JExpression Parser Version 1.0.2:  Usage is one of:");
      System.out.println("         java JavaParser < inputfile");
      System.out.println("OR");
      System.out.println("         java JavaParser inputfile");
      return;
    }
    try {
      parser.SourceFile();
      System.out.println("JExpression Parser Version 1.0.2:  Java program parsed successfully.");
    } catch (ParseException e) {
      System.out.println("JExpression Parser Version 1.0.2:  Encountered errors during parse.");
    }
  }
  
  public ACParser(File file) throws FileNotFoundException {
    this(new FileReader(file));
    _currentFile = file;
  }
  
  public ACParser(String file) {
    this(new StringReader(file));
    _currentFile = null;
  }

  /** Strips off the "l" or "L" off the end of long literals */   
  private static String _stripL(String in) {
    if (in.endsWith("l") || in.endsWith("L")) {
      return in.substring(0, in.length() - 1);
    }
    else {
      return in;
    }
  }

  /** Returns in without first and last character. */
  private static String _stripQuotes(String in) {
    int len = in.length();

    return in.substring(1, len - 1);
  }

  /**
   * Creates a source location that starts at the given first token
   * and ends in the last token yet read.
   */
  private SourceInfo _loc(Token first) {
    return new SourceInfo(_currentFile,
                          first.beginLine,
                          first.beginColumn,
                          token.endLine,
                          token.endColumn);
  }

  /**
   * Creates a source location that starts at the given first AST piece
   * and ends in the last token yet read.
   */
  private SourceInfo _loc(JExpressionIF first) {
    return new SourceInfo(_currentFile,
                          first.getSourceInfo().getStartLine(),
                          first.getSourceInfo().getStartColumn(),
                          token.endLine,
                          token.endColumn);
  }
  
  private void _throwParseException(String message) throws ParseException {
    // The error typically occurs on the next token.
    Token t = token;
    if (token.next != null) {
      t = token.next;
    }
    // If a certain token or sequence of tokens is expected, display it.
    ParseException pe = generateParseException();
//    if (pe.expectedTokenSequences.length == 1) {
//      message += " Expected";
//      for (int i = 0; i < pe.expectedTokenSequences.length; i++) {
//        message += " " + pe.tokenImage[pe.expectedTokenSequences[0][i]];
//      }
//      message += ".";
//    }
    throw new ParseException(_currentFile, message, t, pe.expectedTokenSequences, tokenImage);    
//    _errors.add(new ParseException(_currentFile, message, t, null, tokenImage);
  }
  
      private void _throwParseException(ParseException pe, String message) throws ParseException {
    // Use the embedded error message if thrown from our code
    if (pe.customConstructor) {
      message = pe.getMessage();
    }
    _throwParseException(message);
  }
  
  private String _getTokenImage() {
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < tokenImage.length; i++) {
      sb.append(tokenImage[i] + " ");
    }
    return new String(sb).trim();
  }
  
  private boolean _isAbstract(ModifiersAndVisibility mav) {
    String[] modifiers = mav.getModifiers();
    for (int i = 0; i < modifiers.length; i++) {
      if (modifiers[i].equals("abstract")) {
        return true;
      }      
    }
    return false;
  }
}

//class VariableDeclarator {
//  public Word identifier;
//  public Type type;
//  public VariableInitializerI initializer = ACParser.NO_VARIABLE_INITIALIZER;
//}

class UnmodifiedClassDef {
  public Word name;
  // provide defaults here for things that can be unspecified
  public TypeParameter[] typeParameters = new TypeParameter[0];
  public ReferenceType superclass = ACParser.NO_TYPE;
  public ReferenceType[] interfaces = new ReferenceType[0];
  public BracedBody body;
}

class UnmodifiedInterfaceDef {
  public Word name;
  public TypeParameter[] typeParameters = new TypeParameter[0];
  public ReferenceType[] superinterfaces = new ReferenceType[0];
  public BracedBody body;
//  public AbstractMethodDef[] methods = new AbstractMethodDef[0];
//  public FinalStaticFieldDef[] fields = new FinalStaticFieldDef[0];
//  public StaticInnerDefI[] inners = new StaticInnerDefI[0];
}

PARSER_END(ACParser)


/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */
/* Skip all comments, checking that they're valid syntatically.  We skip
 * them because once we've parsed the class, if we find that it's valid,
 * we'll grab the text of the file and augment it as needed.  The comments
 * will remain in their original positions.
 */
SKIP :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SKIP :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n"> : DEFAULT
}

<IN_FORMAL_COMMENT>
SKIP :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SKIP :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT, IN_FORMAL_COMMENT, IN_MULTI_LINE_COMMENT>
SKIP :
{
  < ~[] >
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STRICTFP: "strictfp" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
}

/* LITERALS */

TOKEN :
{
  /** INTEGER_LITERAL is never used */
//  < INTEGER_LITERAL:
//        <DECIMAL_LITERAL> (["l","L"])?
//      | <HEX_LITERAL> (["l","L"])?
//      | <OCTAL_LITERAL> (["l","L"])?
//  >
//|
  < DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < LONG_DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* (["l", "L"]) >
|
  < LONG_HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ (["l", "L"]) >
|
  < LONG_OCTAL_LITERAL: "0" (["0"-"7"])* (["l", "L"]) >
|
  < DOUBLE_FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["d","D"]
  >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/* IDENTIFIERS */

TOKEN :
{ // deferred
//  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
//|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

TOKEN:
{
 < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
}

TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
  
}

TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
{
 matchedToken.kind = RSSHIFT1;
 matchedToken.image = ">@1";
 matchedToken.next = new Token(matchedToken.beginLine,matchedToken.beginColumn,
                               matchedToken.beginLine, matchedToken.beginColumn + 1);
 matchedToken.next.kind = RSSHIFT2;
 matchedToken.next.image = ">@2";
}
| < RUNSIGNEDSHIFT: ">>>" >
{
 matchedToken.image = ">`1";
 matchedToken.kind = RUSHIFT1;
 matchedToken.next = new Token(matchedToken.beginLine,matchedToken.beginColumn,
                               matchedToken.beginLine, matchedToken.beginColumn + 1);
 matchedToken.next.kind = RUSHIFT2;
 matchedToken.next.image = ">`2";
 matchedToken.next.next = new Token(matchedToken.beginLine,matchedToken.beginColumn,
                                    matchedToken.beginLine, matchedToken.beginColumn + 2);
 matchedToken.next.next.kind = RUSHIFT3;
 matchedToken.next.next.image = ">`3";
}
| < RSSHIFT1: ">@1" >
| < RSSHIFT2: ">@2" >
| < RUSHIFT1: ">`1" >
| < RUSHIFT2: ">`2" >
| < RUSHIFT3: ">`3" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}

TOKEN:
{
  <OTHER: ~[]>
}

  JAVACODE
    void _errorChar(char c) {
    _throwParseException("'" + c + "' expected.");
  }
  
  JAVACODE
  boolean _ignoreChar(char c){
    return true;
  }
  
  JAVACODE
  void _errorString(String s) {
    StringBuffer message = new StringBuffer();
    for (int i = 0; i < s.length(); i++) {
      if (i > 0) {
        if (i == (s.length() - 1)) {
          message.append(" or ");
        }
        else {
          message.append(", ");
        }
      }
      message.append(s.charAt(i));
    }
    _throwParseException(message.toString() + " expected.");
  }
  
  JAVACODE
  boolean _ignoreString(String s){
    return true;
  }

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

SourceFile SourceFile() :
{
  LinkedList/*<PackageStatement>*/ packageStatements = new LinkedList/*<PackageStatement>*/();
  LinkedList/*<ImportStatement>*/ importStatements = new LinkedList/*<ImportStatement>*/();
  LinkedList/*<ClassDef>*/ classes = new LinkedList/*<ClassDef>*/();
  LinkedList/*<InterfaceDef>*/ interfaces = new LinkedList/*<InterfaceDef>*/();
  PackageStatement temp1;
  ImportStatement temp2;
  ClassDef temp3;
  InterfaceDef temp4;
  Token temp5;
  Token first = getToken(1);

  /**
   * collects body items outside of a class definition
   * emptied and added to a class once a class definition is defined
   */
  BodyItemI bi;
  BodyItemI tempbi;
  LinkedList/*<BodyItemI>*/ items = new LinkedList/*<BodyItemI>*/();
}
{
  try {
//    (
//     try{
//        temp1 = PackageStatement() {
//          packageStatements.addLast(temp1);
//        }
//      }catch(ParseException e){}
//    )*
//    (
//     try{
//       temp2 = ImportStatement() {
//         importStatements.addLast(temp2);
//       }
//     }catch(ParseException e){}
//    )*
      
    (
     LOOKAHEAD(<IMPORT>)
       temp2 = ImportStatement() {
         importStatements.addLast(temp2);
       }
      |
     LOOKAHEAD(<PACKAGE>)
        temp1 = PackageStatement() {
          packageStatements.addLast(temp1);
    }
       |
     LOOKAHEAD(ModifiersAndVisibility() <CLASS>)
     temp3 = ClassDef() {
      classes.addLast(temp3);
      while(items.size() > 0){
//        temp3.getBody().getItems().add(items.removeFirst());
        items.removeFirst();
      }
    }
     |
     LOOKAHEAD( ModifiersAndVisibility() <INTERFACE> )
     temp4 = InterfaceDef() {
       interfaces.addLast(temp4);
     }
     | LOOKAHEAD(2)
     tempbi = Initializer()
     | LOOKAHEAD(MethodDefLookahead())
     tempbi = MethodDef()
       | LOOKAHEAD(ConstructorDefLookahead())
     tempbi = ConstructorDef()
       | LOOKAHEAD(ModifiersAndVisibility() Type() <IDENTIFIER>)
     tempbi = VariableDeclaration() (<SEMICOLON> | _ignoreString(";("))
////     LOOKAHEAD( BodyItemLookahead() )
////     bi = BodyItem(){
////       // then temp3 is the most recent class definition (above us)
////       if(classes.size() > 0){
////         temp3 = classes.getLast();
////         BodyItemI[] bia = temp3.getBody().getItems();
////         for(int i=0;i<bia.length;i++){
////           tempbi = bia[i];
////           items.add(tempbi);
////         }
////         items.addLast(bi);
////         ClassDef c = classes.removeLast();
////         BracedBody newBody = new BracedBody(c.getBody().getSourceInfo(), items.toArray(new BodyItemI[0]));
////         classes.addLast(new ClassDef(c.getSourceInfo(), c.getMav(), c.getName(), c.getTypeParameters(), c.getInterfaces(), newBody, c.getSuperclass()));
////       }else{
////         items.add(bi);
////       }
////     }
     |
     LOOKAHEAD(AnyTokenButEOF())
     AnyTokenButEOF()
       )*

       <EOF> {
       return new SourceFile(_loc(first),
                             packageStatements.toArray(new PackageStatement[0]),
                             importStatements.toArray(new ImportStatement[0]),
                             classes.toArray(new ClassDef[0]),
                             interfaces.toArray(new InterfaceDef[0]));
       }
       
//     |
//       <OTHER>
  }
  catch (ParseException pe) {
//    if (pe.currentToken.next != null && pe.currentToken.next.kind == EOF) {
//      _throwParseException(pe, "'}' expected.");
//    }
//    else {
    /** Hmm, how to also indicate that interfaces can appear here w/o messing up elementary level? */
      _throwParseException(pe, "A class declaration must appear here: found " + getToken(1));
//    }
  }
}
  void AnyTokenButEOF(): 
  {
    LinkedList/*<String>*/ words = new LinkedList/*<String>*/();
    Token t = getToken(1);
  }{
  ((t = <ABSTRACT> |
    t = < BOOLEAN> |
    t = <BREAK> |
    t = <BYTE> |
    t = <CASE> |
    t = <CATCH> |
    t = <CHAR> |
    t = <CLASS> |
    t = <CONST> |
    t = <CONTINUE> |
    t = <_DEFAULT> |
    t = <DO> |
    t = <DOUBLE> |
    t = <ELSE> |
    t = <EXTENDS> |
    t = <FALSE> |
    t = <FINAL> |
    t = <FINALLY> |
    t = <FLOAT> |
    t = <FOR> |
    t = <GOTO> |
    t = <IF> |
    t = <IMPLEMENTS> |
    t = <IMPORT> |
    t = <INSTANCEOF> |
    t = <INT> |
    t = <INTERFACE> |
    t = <LONG> |
    t = <NATIVE> |
    t = <NEW> |
    t = <NULL> |
    t = <PACKAGE> |
    t = <PRIVATE> |
    t = <PROTECTED> |
    t = <PUBLIC> |
    t = <RETURN> |
    t = <SHORT> |
    t = <STRICTFP> |
    t = <STATIC> |
    t = <SUPER> |
    t = <SWITCH> |
    t = <SYNCHRONIZED> |
    t = <THIS> |
    t = <THROW> |
    t = <THROWS> |
    t = <TRANSIENT> |
    t = <TRUE> |
    t = <TRY> |
    t = <VOID> |
    t = <VOLATILE> |
    t = <WHILE> |
    t = <DECIMAL_LITERAL> |
    t = <HEX_LITERAL> |
    t = <OCTAL_LITERAL> |
    t = <LONG_DECIMAL_LITERAL> |
    t = <LONG_HEX_LITERAL> |
    t = <LONG_OCTAL_LITERAL> |
    t = <DOUBLE_FLOATING_POINT_LITERAL> |
    t = <FLOATING_POINT_LITERAL> |
    t = <CHARACTER_LITERAL> |
    t = <STRING_LITERAL> |
    t = <IDENTIFIER> |
    t = <LPAREN> |
    t = <RPAREN> |
    t = <LBRACE> |
    t = <RBRACE> |
    t = <LBRACKET> |
    t = <RBRACKET> |
    t = <SEMICOLON> |
    t = <COMMA> |
    t = <DOT> |
    t = <ASSIGN> |
    t = <GT> |
    t = <LT> |
    t = <BANG> |
    t = <TILDE> |
    t = <HOOK> |
    t = <COLON> |
    t = <EQ> |
    t = <LE> |
    t = <GE> |
    t = < NE> |
    t = <SC_OR> |
    t = <SC_AND> |
    t = <INCR> |
    t = <DECR> |
    t = <PLUS> |
    t = <MINUS>|
    t = <STAR> |
    t = <SLASH> |
    t = <BIT_AND> |
    t = <BIT_OR> |
    t = <XOR> |
    t = <REM> |
    t = <LSHIFT> |
    t = <RSIGNEDSHIFT> |
    t = <RSSHIFT1> |
    t = <RSSHIFT2> |
    t = <RUSHIFT1> |
    t = <RUSHIFT2> |
    t = <RUSHIFT3> |
    t = <PLUSASSIGN> |
    t = <MINUSASSIGN> |
    t = <STARASSIGN> |
    t = <SLASHASSIGN> |
    t = <ANDASSIGN> |
    t = <ORASSIGN> |
    t = <XORASSIGN> |
    t = <REMASSIGN> |
    t = <LSHIFTASSIGN> | 
    t = <RSIGNEDSHIFTASSIGN> |
    t = <RUNSIGNEDSHIFTASSIGN> |
    t = <OTHER>
  )
     { 
//    System.out.println("chewing: " + t.image);
      words.addLast(t.image);
      getToken(1);
     }
  )
}
    
    
    
    
//JExpression JExpression() :
//{
//  JExpression ret;
//}
//{
//  ( ret = Operator() |
//    LOOKAHEAD(MethodDefLookahead())
//    ret = MethodDef() |
//    LOOKAHEAD(VariableDeclarationLookahead())
//    ret = VariableDeclaration() |
//    LOOKAHEAD(<IDENTIFIER> <DOT>)
//    ret = CompoundWord() |   
//    ret = Word() |
//    ret = Literal() |
//    ret = Bracketed() |
//    ret = Braced() |
//    ret = Parenthesized() |
//    LOOKAHEAD( ( <ABSTRACT> | <FINAL> | <PUBLIC> | <STRICTFP> )* <CLASS> )
//    ret = ClassDef() |
//    LOOKAHEAD( ( <STATIC> | <ABSTRACT> | <FINAL> | <PUBLIC> | <PROTECTED> | <PRIVATE> )* <INTERFACE> )
//    ret = InterfaceDef() |
////    ret = CommaSeparatedList() |
//    //ret = AngleBracketed() |
////    ret = LineCommented() |
////    ret = BlockCommented() |
////    ret = DocCommented() |
//    ret = Statement()
////    ret = BracedStatement()
//     
//  )
//  {
//    return ret;
//  }
//}
  
void MethodDefLookahead() :
{}
{
//  ( <PUBLIC> | <PROTECTED> | <PRIVATE> | <STATIC> | <ABSTRACT> | <FINAL> |
// <NATIVE> | <SYNCHRONIZED> )*
  ModifiersAndVisibility()
 [ TypeParameters() ]
  ReturnType() <IDENTIFIER> <LPAREN>//(FormalParameter() | <RPAREN>)
}
  
void ConstructorDefLookahead() :
{}
{
//  ( <PUBLIC> | <PROTECTED> | <PRIVATE> | <STATIC> | <ABSTRACT> | <FINAL> |
// <NATIVE> | <SYNCHRONIZED> )*
  ModifiersAndVisibility()
  <IDENTIFIER> <LPAREN>(FormalParameter() | <RPAREN>)
}

// This production is to determine lookahead only.  It will be used instead
// of MethodDefLookahead because of the added complexity of
// parametric methods and types fooling the lookahead.
void VariableDeclarationLookahead() :
{}
{
 ( <PUBLIC> | <PROTECTED> | <PRIVATE> | <STATIC> | <ABSTRACT> | <FINAL> |
 <TRANSIENT> | <VOLATILE> )*
 Type() <IDENTIFIER> ( <SEMICOLON> | <ASSIGN> | <COMMA> | <LBRACKET> )
}

Literal Literal() :
{
  Token t;
  Literal literal;
  Token first = getToken(1);
}
{
  try {
    literal = IntegerLiteral(false, first) { return literal; }
    |
      literal = FloatLiteral() { return literal; }
    |
      t = <CHARACTER_LITERAL> { return new CharLiteral(_loc(t), CharConverter.unescapeChar(_stripQuotes(t.image))); }
    |
      t = <STRING_LITERAL> { return new StringLiteral(_loc(t), CharConverter.unescapeString(_stripQuotes(t.image))); }
    |
      literal = BooleanLiteral() { return literal; }
    |
      <NULL> { return new NullLiteral(_loc(first)); }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "This is an illegal literal!");
  }
}

PackageStatement PackageStatement() :
{ 
  CompoundWord cw;
  Token first = getToken(1);
}
{
  <PACKAGE> 
    try {
    cw = CompoundWord() 
    {//{ System.out.println("cw = " + cw); 
      return new PackageStatement(_loc(first), cw);
    }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "Illegal package name!");
  }
}

ImportStatement ImportStatement() :
{
  CompoundWord cw;
  Token first = getToken(1);
}
{
  <IMPORT>
  cw = CompoundWord() 
  try {
    (<DOT> <STAR> {
      return new PackageImportStatement(_loc(first), cw);
    })
      |
    {
      return new ClassImportStatement(_loc(first), cw);
    }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "Illegal import name!");
  }
}


ModifiersAndVisibility ModifiersAndVisibility() :
{
  LinkedList/*<String>*/ words = new LinkedList/*<String>*/();
  Token t;
  Token first = getToken(1);
}
{  
 (
  (
   t = <PUBLIC> 
   | t = <PROTECTED> 
   | t = <PRIVATE> 
   | t = <STATIC> 
   | t = <ABSTRACT> 
   | t = <FINAL> 
   | t = <TRANSIENT> 
   | t = <VOLATILE> 
   | t = <NATIVE> 
   | t = <SYNCHRONIZED> 
   | t = <STRICTFP>
  )
    {
//   System.out.println("adding " + t.image);
     words.addLast(t.image);
    }
 )*
 { 
   // If there are no modifiers, then we make our own SourceInfo that
   // points to the beginning of the following token.
   // Otherwise, the coordinates are backwards.
    SourceInfo si;
    if (words.size() == 0) {
      si = new SourceInfo(_currentFile,
                          first.beginLine,
                          first.beginColumn,
                          first.beginLine,
                          first.beginColumn);
    }
    else {
      si = _loc(first);
    }
    return new ModifiersAndVisibility(si, words.toArray(new String[0])); 
 }
}

ClassDef ClassDef() :
{
  ModifiersAndVisibility modifiers;
  UnmodifiedClassDef decl;
  Token first = getToken(1);
//  System.out.println("looking at: " + first.image);
  _inInterface = false;
}
{
  modifiers = ModifiersAndVisibility()
  decl = UnmodifiedClassDef()
  {
    // parse the modifiers later
//    if ((mav.isStatic) ||
//        (mav.visibility == Visibility.PRIVATE) ||
//        (mav.visibility == Visibility.PROTECTED))
//    {
//      throw new RuntimeException("Invalid modifiers for top-level class!");
//    }

    return new ClassDef(_loc(first), 
                        modifiers,
                        decl.name,
                        decl.typeParameters,
                        decl.interfaces,
                        decl.body,
                        decl.superclass);
  }
}

UnmodifiedClassDef UnmodifiedClassDef() :
{
  UnmodifiedClassDef decl = new UnmodifiedClassDef();
  Word name;
}
{
  <CLASS>
  name = Word() { decl.name = name; }
  [ decl.typeParameters = TypeParameters() ]
  [ <EXTENDS> decl.superclass = ClassOrInterfaceType() ]
  [ <IMPLEMENTS> decl.interfaces = NameList() ]
    (<LBRACE> | _ignoreChar('{'))
   decl.body = BracedBody() 
    (<RBRACE> | _ignoreChar('}'))

  {
    return decl;
  }
}



InnerClassDef InnerClassDef() :
{
  ModifiersAndVisibility modifiers;
  UnmodifiedClassDef decl;
  Token first = getToken(1);
}
{
  modifiers = ModifiersAndVisibility()
  decl = UnmodifiedClassDef()
  {
    return new InnerClassDef(_loc(first), 
                             modifiers,
                             decl.name,
                             decl.typeParameters,
                             decl.interfaces,
                             decl.body,
                             decl.superclass);
  }
}
//  <CLASS>
//    
//    name = Word()
//    [ typeParams = TypeParameters() ]
//
//    [ <EXTENDS> superClass = ClassOrInterfaceType() ]
//    
//    [ <IMPLEMENTS> interfaces = NameList() ]
//
//  body = BracedBody() {
//    return new ClassDef(_loc(first),
//                                modifiers,
//                                name,
//                                typeParams,
//                                superClass,
//                                interfaces,
//                                body);
//  }
//}

InterfaceDef InterfaceDef() :
{
  ModifiersAndVisibility modifiers;
  UnmodifiedInterfaceDef decl;
  Token first = getToken(1);
  _inInterface = true;
}
{
  modifiers = ModifiersAndVisibility()
  decl = UnmodifiedInterfaceDef()
  {
    // parse the modifiers later
//    if ((mav.isStatic) ||
//        (mav.visibility == Visibility.PRIVATE) ||
//        (mav.visibility == Visibility.PROTECTED) ||
//        (mav.modifier == ClassModifier.FINAL))
//    {
//      throw new RuntimeException("invalid modifiers for top-level interface");
//    }

    return new InterfaceDef(_loc(first),
                            modifiers,
                            decl.name,
                            decl.typeParameters,
                            decl.superinterfaces,
                            decl.body);
  }
}

UnmodifiedInterfaceDef UnmodifiedInterfaceDef() :
{
  UnmodifiedInterfaceDef decl = new UnmodifiedInterfaceDef();
//  LinkedList methodList = new LinkedList();
//  LinkedList fieldList = new LinkedList();
//  LinkedList innerList = new LinkedList();
  BracedBody body;
  Word name;
}
{
  <INTERFACE>
  name = Word() { decl.name = name; }
  [ decl.typeParameters = TypeParameters() ]
  [ <EXTENDS> decl.superinterfaces = NameList() ]
    (<LBRACE> | _ignoreChar('{'))
    body = BracedBody()
    (<RBRACE> | _ignoreChar('}'))
  {
//    decl.methods = (AbstractMethodDef[]) methodList.toArray(new AbstractMethodDef[0]);
//    decl.fields = (FinalStaticFieldDef[]) fieldList.toArray(new FinalStaticFieldDef[0]);
//    decl.inners = (StaticInnerDefI[]) innerList.toArray(new StaticInnerDefI[0]);
    decl.body = body;
    return decl;
  }
}

InnerInterfaceDef InnerInterfaceDef() :
{
  ModifiersAndVisibility modifiers;
  UnmodifiedInterfaceDef decl;
  Token first = getToken(1);
  boolean oldInInterface = _inInterface;
  _inInterface = true;
}
{
  modifiers = ModifiersAndVisibility()
  decl = UnmodifiedInterfaceDef()
  {
    _inInterface = oldInInterface;
    return new InnerInterfaceDef(_loc(first),
                            modifiers,
                            decl.name,
                            decl.typeParameters,
                            decl.superinterfaces,
                            decl.body);
  }
}

// Represents the bodies of classes, interfaces, and methods.
BracedBody BracedBody() :
{
  LinkedList/*<BodyItemI>*/ items = new LinkedList/*<BodyItemI>*/();
  BodyItemI temp;
  Token first = getToken(1);
}
{
//  <LBRACE>  // Merging the definitions of BracedBody and BlockStatements so must remove braces
    (
     try{
       temp = BodyItem()
         { items.addLast(temp); }
    }catch(ParseException e){
       break;
    }
    )*
//    <RBRACE>
  {
    SourceInfo si;
    if (items.size() == 0) {
      si = _loc(token);
    }
    else {
      si = _loc(first);
    }
    return new BracedBody(si, items.toArray(new BodyItemI[0]));
  }    
}

// A BodyItem is a method declaration, field declaration, statments, initializer, constructor, or inner declaration.
BodyItemI BodyItem() :
{
  BodyItemI temp;
}
{
  try {
    (
     LOOKAHEAD(ModifiersAndVisibility() <CLASS>)
     temp = InnerClassDef()
       | LOOKAHEAD(ModifiersAndVisibility() <INTERFACE>)
       temp = InnerInterfaceDef()
       | LOOKAHEAD(2)
       temp = Initializer()
       | LOOKAHEAD(MethodDefLookahead())
       temp = MethodDef()
       | LOOKAHEAD(ConstructorDefLookahead())
       temp = ConstructorDef()
       | LOOKAHEAD(ModifiersAndVisibility() Type() <IDENTIFIER>)
       temp = VariableDeclaration() (<SEMICOLON> | _errorString(";("))
       | temp = Statement()
       )
    {
      return temp;
    }
  }
  catch(ParseException pe) {
    _throwParseException(pe, "This cannot appear in a class body!");
  }
}

MethodDef MethodDef() :
{
  Token first = getToken(1);
  ModifiersAndVisibility modifiers;
  TypeParameter[] typeParams = new TypeParameter[0];
  ReturnTypeI returnType;
  Word name;
  FormalParameter[] params;
  ReferenceType[] throwsArray = new ReferenceType[0];
  BracedBody body;
}
{
  try {
    modifiers = ModifiersAndVisibility()
     [ typeParams = TypeParameters() ]
      returnType = ReturnType()
      name = Word()
      params = FormalParameters()

      // such weird syntax. brackets after formal params to make result type array!
      // This is obsolete but allowed as per JLS 8.4
      (
       LOOKAHEAD(<LBRACKET>)
       <LBRACKET> <RBRACKET>
       {
      if (returnType instanceof Type) {
        returnType = new ArrayType(_loc(returnType), ((Type)returnType).getName() + "[]", (Type) returnType);
      }
      else { // void return
        _throwParseException("Cannot have method return array if base type is void!");
      }
    }
    )*

      [ <THROWS> throwsArray = NameList() ] 
    { if (!_isAbstract(modifiers) && !_inInterface) { 
      body = ConcreteMethodBody();
      return new ConcreteMethodDef(_loc(first), 
                                   modifiers,
                                   typeParams,
                                   returnType,
                                   name,
                                   params,
                                   throwsArray,
                                   body);
    }
    else {
      AbstractMethodBody();
      return new AbstractMethodDef(_loc(first), 
                                   modifiers,
                                   typeParams,
                                   returnType,
                                   name,
                                   params,
                                   throwsArray);
    }
    }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in a method declaration!");
  }
}

BracedBody ConcreteMethodBody() :
{
  BracedBody body;}
{
  (<LBRACE> | _errorChar('{')) body = BracedBody() (<RBRACE> | _errorChar('}')) 
  { return body;
  }
}
  
void AbstractMethodBody() :
{}
{
  (<SEMICOLON> | _errorChar(';'))
}
  
VariableDeclaration VariableDeclaration() :
{
  ModifiersAndVisibility modifiers;
  LinkedList/*<VariableDeclarator>*/ variableDeclarators;
//  Type type;
//  Word name;
//  VariableInitializerI initializer;
  Token first = getToken(1);
} 
{
  try {
    modifiers = ModifiersAndVisibility()
      variableDeclarators = VariableDeclaratorList()
//      type = Type()
      //      name = Word()
      //      params = ParameterList()
      //      initializer = VariableInitializer()
//      <SEMICOLON> {
    {
      return new VariableDeclaration(_loc(first), 
                                     modifiers,
                                     variableDeclarators.toArray(new VariableDeclarator[0]));
    }    
  }
  catch (ParseException pe) {
    _throwParseException(pe, "This is not a valid variable declaration!");
  }
  
}

ReferenceType[] NameList() :
{
  LinkedList/*<ReferenceType>*/ list = new LinkedList/*<ReferenceType>*/();
  ReferenceType temp;
}
{
  temp = ClassOrInterfaceType() { list.add(temp); }
  (
    <COMMA>
    temp = ClassOrInterfaceType() { list.add(temp); }
  )*
  {
    return list.toArray(new ReferenceType[0]);
  }
}

ReturnTypeI ReturnType() :
{
  ReturnTypeI ret;
  Token first = getToken(1);
}
{
  (
    <VOID> { ret = new VoidReturn(_loc(first), "void"); }
  |
    ret = Type()
  )
  {
    return ret;
  }
}
    
//FormalParameterList FormalParameterList() :
//{
//  Object temp;
//  Token first = getToken(1);
//  LinkedList params = new LinkedList();
//}
//{
//  (<LPAREN> | _errorChar('('))
//  ( <RPAREN> { return new FormalParameterList(_loc(first), (FormalParameter[])params.toArray(new FormalParameter[0])); }
//  |
//  temp = FormalParameter() {
//    params.addLast(temp);
//  }
//   (<COMMA>
//    temp = FormalParameter() {
//     params.addLast(temp);
//   })*
//   (<RPAREN> | _errorChar(')')) { return new FormalParameterList(_loc(first), (FormalParameter[])params.toArray(new FormalParameter[0])); }
//   )
//}

FormalParameter[] FormalParameters() :
{
  LinkedList/*<FormalParameter>*/ list = new LinkedList/*<FormalParameter>*/();
  FormalParameter temp;
  Token first = getToken(1);
}
{
  (<LPAREN> | _errorChar('('))
  [
    temp = FormalParameter() { list.add(temp); }
    (
      <COMMA>
      temp = FormalParameter() { list.add(temp); }
    )*
  ]
  (<RPAREN> | _errorString("),"))
  {
    return list.toArray(new FormalParameter[0]);
  }
}

FormalParameter FormalParameter() :
{
  boolean isFinal = false;
  Type type;
  VariableDeclarator declarator;
  Token first = getToken(1);
}
{
  [ <FINAL> { isFinal = true; } ]
  type = Type()
  declarator = VariableDeclarator(type)
  { 
    if (declarator instanceof InitializedVariableDeclarator) {
      _throwParseException("Cannot assign values to parameters!");
    }
    return new FormalParameter(_loc(first), declarator, isFinal); }
}

ConstructorDef ConstructorDef() :
{
  ModifiersAndVisibility visibility;
  Token name = null;
  FormalParameter[] formalParameters;
  ReferenceType[] throwsArray = new ReferenceType[0];
  BracedBody code;
  Token first = getToken(1);

  // null will indicate that there is none
  ConstructorInvocation invocation = null;
//  Token bodyFirst;
}
{
//  [
//    <PUBLIC> { visibility = Visibility.PUBLIC; }
//  | <PROTECTED> { visibility = Visibility.PROTECTED; }
//  | <PRIVATE> { visibility = Visibility.PRIVATE; }
//  ]
  try {
    visibility = ModifiersAndVisibility()
//      (name = <IDENTIFIER> | _errorString("identifier"))
      name = <IDENTIFIER>
      formalParameters = FormalParameters()
      [
       <THROWS>
       throwsArray = NameList()
         ]
      (<LBRACE> | _errorChar('{'))
      [
       LOOKAHEAD(ExplicitConstructorInvocation())
         invocation = ExplicitConstructorInvocation()
         ]
      code = BracedBody() // changed from BlockStatements()
      (<RBRACE> | _errorChar('}'))
    {
      ConstructorBody body;
      if (invocation == null) {
        body = new NormalConstructorBody(_loc(code), code);
      }
      else {
        body = new ConstructorBodyWithExplicitConstructorInvocation(_loc(code), code, invocation);
      }
      
      return new ConstructorDef(_loc(first),
                                name.image,
                                visibility,
                                formalParameters,
                                throwsArray,
                                body);
    }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in a constructor definition!");
  }
}

ConstructorInvocation ExplicitConstructorInvocation() :
{
  Token first = getToken(1);
  Expression[] arguments;

  // null means no qualifier for super.
  Expression qualifier = null;
}
{
  LOOKAHEAD(<THIS> Arguments() <SEMICOLON>)
  <THIS>
  arguments = Arguments()
  <SEMICOLON>
  {
    return new ThisConstructorInvocation(_loc(first), arguments);
  }
|
  // somewhat messy...
  // Although the semicolon string is passed to expression, the expression parsing should come to a point where 
  // it cannot parse anymore tokens in, that is, the dot super.  The semicolon is there primarily so that we stop 
  // parsing before going all the way to the end of the file if there is no dot super.  This difficulty arises 
  // because we have no concept of a primary expression, which is what should go here.
  [ LOOKAHEAD(Expression(";") <DOT> <SUPER>) qualifier = Expression(";") <DOT>]
  <SUPER>
  arguments = Arguments()
  (<SEMICOLON> | _errorChar('l'))
  {
    if (qualifier == null) {
      return new UnqualifiedSuperConstructorInvocation(_loc(first), arguments);
    }
    else {
      return new QualifiedSuperConstructorInvocation(_loc(first), arguments, qualifier);
    }
  }
}

Initializer Initializer() :
{
  boolean isStatic = false;
  Block code;
  Token first = getToken(1);
}
{
  [ <STATIC> { isStatic = true; } ]
  code = Block()
  {
    if (isStatic) {
      return new StaticInitializer(_loc(first), code);
    }
    else {
      return new InstanceInitializer(_loc(first), code);
    }
  }
}

/*
 * Type, name and expression syntax follows.
 */

Type Type() :
{
  Type type;
  Token first = getToken(1);
}
{
 ( LOOKAHEAD(3) type = PrimitiveType() | type = ReferenceType() )
  (
   LOOKAHEAD(<LBRACKET>)
    <LBRACKET> (<RBRACKET> | _errorChar(']'))
    { type = new ArrayType(_loc(first), type.getName() + "[]", type); }
  )*
  {
    return type;
  }
}

PrimitiveType PrimitiveType() :
{
  Token name;
}
{
  (
    name = <BOOLEAN>
  |
    name = <CHAR>
  |
    name = <BYTE>
  |
    name = <SHORT>
  |
    name = <INT>
  |
    name = <LONG>
  |
    name = <FLOAT>
  |
    name = <DOUBLE>
  )
  { return new PrimitiveType(_loc(name), name.image); }
}

ReferenceType ReferenceType() :
{
  ReferenceType type;
}
{
  ( LOOKAHEAD(2) type = ClassOrInterfaceType() | type = TypeVariable() )
   {
     return type;
   }
}

ArrayType ArrayType() :
{
  Type elemType;
  ArrayType arrayType = null;
  Token first = getToken(1);
}
{
 ( LOOKAHEAD(2) elemType = PrimitiveType() | elemType = ReferenceType() )
  (
    <LBRACKET> <RBRACKET>
    {
      if (arrayType == null) {
        arrayType = new ArrayType(_loc(first), elemType.getName() + "[]", elemType);
      }
      else {
        arrayType = new ArrayType(_loc(first), arrayType.getName() + "[]", arrayType);
      }
    }
  )+
  { return arrayType; }
}

TypeVariable TypeVariable() :
{
  Token name;
}
{
 name = <IDENTIFIER>
  {
    return new TypeVariable(_loc(name), name.image);
  }
}

/** have to break out each period inside the name. */
ReferenceType ClassOrInterfaceType() :
{
  Type[] typeArguments = new Type[0];
  Token identToken;
  ReferenceType type;
}
{
 identToken = <IDENTIFIER>
  [ LOOKAHEAD(<LT>) typeArguments = TypeArguments() ]
  {
    type = new ClassOrInterfaceType(_loc(identToken), identToken.image, typeArguments);
    typeArguments = new Type[0];
  }

  (
    LOOKAHEAD(2) // needed due to possible .class case
    <DOT>
    identToken = <IDENTIFIER>
    [ LOOKAHEAD(<LT>) typeArguments = TypeArguments() ]
    {
      ClassOrInterfaceType right = new ClassOrInterfaceType(_loc(identToken), identToken.image, typeArguments);
      typeArguments = new Type[0];
      type = new MemberType(_loc(type), type.getName() + "." + right.getName(), type, right);
    }
  )*

  { return type; }
}

Type[] TypeArguments() :
{
  LinkedList/*<Type>*/ list = new LinkedList/*<Type>*/();
  Type temp;
}
{
 <LT>

 ( LOOKAHEAD(ArrayType()) temp = ArrayType() | temp = ReferenceType() )
  {
    list.add(temp);
  }

 (
    [<COMMA>]
    ( LOOKAHEAD(ArrayType()) temp = ArrayType() | temp = ReferenceType() )
    {
      list.add(temp);
    }
  )*

  RightAngledBracket()

  {
    return list.toArray(new Type[0]);
  }
}

TypeParameter[] TypeParameters() :
{
  LinkedList/*<TypeParameter>*/ list = new LinkedList/*<TypeParameter>*/();
  TypeParameter temp;
}
{
 <LT>
 temp = TypeFormalParameter() { list.add(temp); }
  (
    [<COMMA>]
    temp = TypeFormalParameter() { list.add(temp); }
  )*
  RightAngledBracket()
  {
    return list.toArray(new TypeParameter[0]);
  }
}

Token RightAngledBracket() :
{
  Token t;
}
{
 ( t=<GT> | t=<RSSHIFT1> | t=<RSSHIFT2> | t=<RUSHIFT1> | t=<RUSHIFT2> | t=<RUSHIFT3> )
  { return t; }
}

TypeParameter TypeFormalParameter() :
{
  TypeVariable variable;
  ReferenceType bound = NO_TYPE;
  Token first = getToken(1);
}
{
 variable = TypeVariable()
  [
    <EXTENDS>
    bound = ClassOrInterfaceType()
  ]
  {
    return new TypeParameter(_loc(first), variable, bound);
  }
}

Literal IntegerLiteral(boolean isNegative, Token first) :
{
  Token token;

  // we have to use biginteger to deal with literals that intentionally overflow
  // 0xfffffffffffffffe is an example, from ACParserTokenManager.java.
  // Also this allows us to deal with Integer/Long.MIN_VALUE
  BigInteger value;
  int maxBitLength;
}
{
  (
    (
      token = <DECIMAL_LITERAL>
      {
        value = new BigInteger(token.image, 10);
        maxBitLength = 31;
      }
    | token = <OCTAL_LITERAL>
      {
        value = new BigInteger(token.image, 8);
        maxBitLength = 32; // it's always positive so use of sign bit ok
      }
    | token = <HEX_LITERAL> // need to strip 0x
      {
        value = new BigInteger(token.image.substring(2), 16);
        maxBitLength = 32; // it's always positive so use of sign bit ok
      }
    )
    {
      if (isNegative) {
        value = value.negate();
      }

      if (value.bitLength() <= maxBitLength) {
        return new IntegerLiteral(_loc(first), value.intValue());
      }
      else {
        throw new RuntimeException("Integer literal too big: " + token.image);
      }
    }
  )
|
  (
    (
      token = <LONG_DECIMAL_LITERAL>
      {
        value = new BigInteger(_stripL(token.image), 10);
        maxBitLength = 63;
      }
    | token = <LONG_OCTAL_LITERAL>
      {
        value = new BigInteger(_stripL(token.image), 8);
        maxBitLength = 64; // it's always positive so use of sign bit ok
      }
    | token = <LONG_HEX_LITERAL> // need to strip 0x
      {
        value = new BigInteger(_stripL(token.image.substring(2)), 16);
        maxBitLength = 64; // it's always positive so use of sign bit ok
      }
    )
    {
      if (isNegative) {
        value = value.negate();
      }

      if (value.bitLength() <= maxBitLength) {
        return new LongLiteral(_loc(first), value.longValue());
      }
      else {
        throw new RuntimeException("Long literal too big: " + token.image);
      }
    }
  )
}

Literal FloatLiteral() :
{
  Token t;
  Token first = getToken(1);
}
{
  (
    t = <DOUBLE_FLOATING_POINT_LITERAL>
    {
      try {
        double value = Double.parseDouble(t.image);
        return new DoubleLiteral(_loc(first), value);
      }
      catch (NumberFormatException e) {
        throw new RuntimeException("Invalid double constant: " + t.image + ". Exception: " + e);
      }
    }
   |
    t = <FLOATING_POINT_LITERAL>
    {
      try {
        float value = Float.parseFloat(t.image);
        return new FloatLiteral(_loc(first), value);
      }
      catch (NumberFormatException e) {
        throw new RuntimeException("Invalid float constant: " + t.image + ". Exception: " + e);
      }
    }
  )
}

BooleanLiteral BooleanLiteral() :
{
  Token first = getToken(1);
}
{
 <TRUE> { return new BooleanLiteral(_loc(first), true); }
|
  <FALSE> { return new BooleanLiteral(_loc(first), false); }
}

StringLiteral StringLiteral() :
{
  Token text;
  Token first = getToken(1);
}
{
  text = <STRING_LITERAL> {
    return new StringLiteral(_loc(first), CharConverter.unescapeString(_stripQuotes(text.image)));
  }
}

ThisLiteral ThisLiteral() :
{
  Token first = getToken(1);
}
{
  <THIS>
  { return new ThisLiteral(_loc(first)); }
}

SuperLiteral SuperLiteral() :
{
  Token first = getToken(1);
}
{
  <SUPER>
  { return new SuperLiteral(_loc(first)); }
}

ClassLiteral ClassLiteral() :
{
  Token first = getToken(1);
}
{
  <CLASS>
  { return new ClassLiteral(_loc(first)); }
}

Word Word() :
{
  Token text;
  Token first = getToken(1);
}
{
  text = <IDENTIFIER> {
    return new Word(_loc(first), text.image);
  }
}

//IntegerLiteral IntegerLiteral() :
//{
//  Token s;
//  Token first = getToken(1);
//}
//{
//  s = <INTEGER_LITERAL> {
//    int i = Integer.parseInt(s.image);
//    return new IntegerLiteral(_loc(first), i);
//  }
//}
//
//FloatLiteral FloatLiteral() :
//{
//  Token s;
//  Token first = getToken(1);
//}
//{
//  s = <FLOATING_POINT_LITERAL> {
//    double d = Double.parseDouble(s.image);
//    return new FloatLiteral(_loc(first), d);
//  }
//}

//CharacterLiteral CharacterLiteral() :
//{
//  Token s;
//  Token first = getToken(1);
//}
//{
//  s = <CHARACTER_LITERAL> {
//    // Char is quoted so the real character is in the middle
//    return new CharacterLiteral(_loc(first), CharConverter.unescapeChar(_stripQuotes(s.image)));
//  }
//}

Operator Operator() :
{
  Token kind;
  Token first = getToken(1);
}
{
  (kind = <ASSIGN> |
   kind = <GT> |
   kind = <LT> |
   kind = <BANG> |
   kind = <TILDE> |
//   kind = <HOOK> |
//   kind = <COLON> |
   kind = <EQ> |
   kind = <LE> |
   kind = <GE> |
   kind = <NE> |
   kind = <SC_OR> |
   kind = <SC_AND> |
   kind = <INCR> |
   kind = <DECR> |
   kind = <PLUS> |
   kind = <MINUS> |
   kind = <STAR> |
   kind = <SLASH> |
   kind = <BIT_AND> |
   kind = <BIT_OR> |
   kind = <XOR> |
   kind = <REM> |
   kind = <LSHIFT> |
   kind = <PLUSASSIGN> |
   kind = <MINUSASSIGN> |
   kind = <STARASSIGN> |
   kind = <SLASHASSIGN> |
   kind = <ANDASSIGN> |
   kind = <ORASSIGN> |
   kind = <XORASSIGN> |
   kind = <REMASSIGN> |
   kind = <LSHIFTASSIGN> |
   kind = <RSIGNEDSHIFTASSIGN> |
   kind = <RUNSIGNEDSHIFTASSIGN> |
   kind = RightShiftOp()
   )
//  kind = (
//    <ASSIGN> | <GT> | <LT> | <BANG> | <TILDE> | <HOOK> | <COLON> | <EQ> | <LE> |
//    <GE> | <NE> | <SC_OR> | <SC_AND> | <INCR> | <DECR> | <PLUS> | <MINUS> |
//    <STAR> | <SLASH> | <BIT_AND> | <BIT_OR> | <XOR> | <REM> | <LSHIFT> |
//    <PLUSASSIGN> | <MINUSASSIGN> | <STARASSIGN> | <SLASHASSIGN> |
//    <ANDASSIGN> | <ORASSIGN> | <XORASSIGN> | <REMASSIGN> | <LSHIFTASSIGN> |
//    <RSIGNEDSHIFTASSIGN> | <RUNSIGNEDSHIFTASSIGN> | RightShiftOp()
//  )
  {
    return new Operator(_loc(first), kind.image);
  }
}
    
Token RightShiftOp() :
{Token t;}
{
 (t = <RSSHIFT1> <RSSHIFT2>) {
   return t;
  }
| (t = <RUSHIFT1> <RUSHIFT2> <RUSHIFT3>) {
  return t;
  }
}

/**
 * This is the construct representing all bracketed expressions
 * within an OtherExpression.  As far as we can tell, this only
 * applies to an array reference, so there can only be one
 * expression within the brackets.
 */
Bracketed Bracketed() :
{ 
  Expression expr;
  Token first = getToken(1);
}
{
  <LBRACKET>
  (
    expr = Expression("]")
  )

  (<RBRACKET> | _errorChar(']')){
    return new Bracketed(_loc(first), expr);
  }
}

/**
 * This is the construct representing all braced expressions
 * within an OtherExpression.  Not sure right now what this
 * applies to.  If there can be multiple Expression within
 * braces in an OtherExpression, then put the delimiter in
 * the string passed to Expression() and parse it out as well.
 * - Not used for now since it can't appear in an OtherExpression.
 */
//Braced Braced() :
//{
//  Expression expr;
//  Token first = getToken(1);
//}
//{
//  try {
//    <LBRACE>
//      (
//       temp = Expression("}") {
//      contents.addLast(temp);
//    }
//    )/* * */
//      
//      ( <RBRACE> {
//      return new Braced(_loc(first), (Expression[])contents.toArray(new Expression[0]));
//    } |
//       <EOF> {
//      //    throw generateParseException();
//      _throwParseException("Missing '}'!");
//    })
//  }
//  catch (ParseException pe) {
//    _throwParseException(pe, "This cannot appear within braces!");
//  }
//}

/**
 * This is the construct representing all parenthesized expressions
 * within an OtherExpression.  Not sure right now what this
 * applies to.  If there can be multiple Expression within
 * braces in an OtherExpression, then put the delimiter in
 * the string passed to Expression() and parse it out as well.
 * Note that method invocations are not OtherExpressions, so
 * we don't think there can be multiple expressions.
 */
Parenthesized Parenthesized() :
{
  Expression expr;
  Token first = getToken(1);
}
{
  <LPAREN>
  (
    expr = Expression(")")
  )
    (<RPAREN> | _errorChar(')')) {
    return new Parenthesized(_loc(first), expr);
  }
}

//// I suppose this can be in either parens or braces so it has to be general
//CommaSeparatedList CommaSeparatedList() :
//{    
//  LinkedList contents = new LinkedList();  
//  Object temp;
//  Token first = getToken(1);
//}
//{  
//  temp = JExpression() { contents.add(temp); }
//  (
//    <COMMA>
//    temp = JExpression() { contents.add(temp); }
//  )* {
//    return new CommaSeparatedList(_loc(first), (JExpression[])contents.toArray(new JExpression[0]));
//  }
//}

//SemicolonSeparatedList SemicolonSeparatedList() :
//{    
//  LinkedList contents = new LinkedList();  
//  Object temp;
//  Token first = getToken(1);
//}
//{  
//  temp = JExpression() { contents.add(temp); }
//  (
//    <SEMICOLON>
//    temp = JExpression() { contents.add(temp); }
//  )* {
//    return new SemicolonSeparatedList(_loc(first), (JExpression[])contents.toArray(new JExpression[0]));
//  }
//}

CompoundWord CompoundWord() :
{    
  LinkedList/*<Word>*/ contents = new LinkedList/*<Word>*/();  
  Word temp;
  Token first = getToken(1);
}
{
  temp = Word() { contents.add(temp); }
  ( 
//   LOOKAHEAD(<DOT> <NEW>) <DOT> {
//    return new CompoundWordBeforeKeyword(_loc(first), (Word[])contents.toArray(new Word[0]));
//  }
//   |
//   LOOKAHEAD(<DOT> <SUPER>) <DOT> {
//    return new CompoundWordBeforeKeyword(_loc(first), (Word[])contents.toArray(new Word[0]));
//  }
//   |
   LOOKAHEAD(<DOT> <IDENTIFIER>)
    <DOT>
    temp = Word() { contents.add(temp); }
  )* {
    return new CompoundWord(_loc(first), contents.toArray(new Word[0]));
  }
}

//LineCommented LineCommented() :
//{
//  StringBuffer contents = new StringBuffer();
//  Token first = getToken(1);
//}
//{
  



/*
 * Statement syntax follows.
 */

Statement Statement() :
{
  Statement temp;
}
{
  try {
  (
   LOOKAHEAD(<LBRACE>)
    temp = Block()
  |
    LOOKAHEAD(2)
    temp = LabeledStatement()  
  |
    temp = EmptyStatement()
  |
    temp = SwitchStatement()
  |
    temp = IfStatement()
  |
    temp = WhileStatement()
  |
    temp = DoStatement()
  |
    temp = ForStatement()
  |
    temp = BreakStatement()
  |
    temp = ContinueStatement()
  |
    temp = ReturnStatement()
  |
    temp = ThrowStatement()
  |
    temp = SynchronizedStatement()
  |
    temp = TryStatement()
  |
   LOOKAHEAD(Expression())
    temp = StatementExpression() 
  )
  { return temp; }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "Invalid statement.");
  }
}
  
LabeledStatement LabeledStatement() :
{
  Token label;
  Statement statement;
}
{
  label = <IDENTIFIER>
  <COLON>
  statement = Statement()
  { return new LabeledStatement(_loc(label), label.image, statement); }
}

//BlockStatementI[] BlockStatements() :
//{
//  LinkedList list = new LinkedList();
//}
//{
//  ( BlockStatement(list) )*
//
//  { return (BlockStatementI[]) list.toArray(new BlockStatementI[0]); }
//}


Block Block() :
{
  BracedBody code;
  Token first = getToken(1);
}
{
  <LBRACE> code = BracedBody() (<RBRACE> | _errorChar('}')) // changed from BlockStatements()
  { return new Block(_loc(first), code); }
}

//void BlockStatement(LinkedList statementList) :
//{
//  BlockStatementI temp;
//  UnmodifiedClassDef decl;
//  boolean isStrictfp = false;
//  Token first = getToken(1);
//}
//{
//  (
//    LOOKAHEAD([ <FINAL> ] Type() <IDENTIFIER>)
//     temp = VariableDeclaration() <SEMICOLON>
//  |
//    temp = Statement() { statementList.add(temp); }
//  |
//    [ <STRICTFP> { isStrictfp = true; } ]
//    decl = UnmodifiedClassDef()
//    {
//      temp = new LocalClassDef(_loc(first),
//                               decl.name,
//                               ClassModifier.NONE,
//                               decl.typeParameters,
//                               isStrictfp,
//                               decl.superclass,
//                               decl.interfaces,
//                               decl.body);
////                               decl.body.constructors,
////                               decl.body.methods,
////                               decl.body.fields,
////                               decl.body.initializers,
////                               decl.body.inners);
//      statementList.add(temp);
//    }
//  )
//}

// pass in the list because we can make multiple variable declarations!
// TODO: This sets location of all variables declared at once to be the entire line!
// This is combined into the VariableDeclaration construct.
//void LocalVariableDeclaration(LinkedList statementList) :
//{
//  boolean isFinal = false;
//  LinkedList/*<VariableDeclarator>*/ variableList;
//  Token first = getToken(1);
//}
//{
//  [ <FINAL> { isFinal = true; } ]
//  variableList = VariableDeclaratorList()
//  {
//    SourceInfo info = _loc(first);
//
//    ListIterator itor = variableList.listIterator();
//    while (itor.hasNext()) {
//      VariableDeclarator decl = (VariableDeclarator) itor.next();
//
//      statementList.add(new LocalVariableDeclaration(info, decl.type, decl.identifier, decl.initializer, isFinal));
//    }
//  }
//}

EmptyStatement EmptyStatement() :
{
  Token first = getToken(1);
}
{
  <SEMICOLON>
  { return new EmptyStatement(_loc(first)); }
}

StatementExpression StatementExpression() :
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.
 */
{
  Expression exp;
//  LinkedList exprPieceList = new LinkedList();
  ExpressionPiece[] pieces;
  ExpressionPiece[] piecesWithNoOtherExpressions;
  ExpressionPiece lastPiece;
  Token first = getToken(1);
  boolean foundAssignment;
}
{   
  try {
    exp = Expression(";") (<SEMICOLON> | _errorChar(';'))
    {
      /* The rest of the method checks that the statement expression is really a statement instead of an expression like 1+1;
       * This process involves checking for assignment operators.  If one is found in the expression, it is permitted.  The
       * expression is also accepted if it ends in a method invocation, allocation expression, or is a pre or post increment/
       * decrement operator.
       */
      pieces = exp.getPieces();
      piecesWithNoOtherExpressions = new ExpressionPiece[pieces.length];
      for (int i = 0; i < pieces.length; i++) {
        if (pieces[i] instanceof OtherExpression) {
          piecesWithNoOtherExpressions[i] = ((OtherExpression)pieces[i]).getExprPiece();
        }
        else {
          piecesWithNoOtherExpressions[i] = pieces[i];
        }
      }
      lastPiece = piecesWithNoOtherExpressions[pieces.length - 1];
      foundAssignment = false;
      for (int i = 0; i < piecesWithNoOtherExpressions.length; i++) {
        //System.out.println("KIND = " + pieces[i] + "instanceof Operator: " + (piecesWithNoOtherExpressions[i] instanceof Operator));
        if (piecesWithNoOtherExpressions[i] instanceof Operator && (((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("+=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("-=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("*=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("/=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("&=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("|=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("^=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("%=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals("<<=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals(">>=") ||
            ((Operator)piecesWithNoOtherExpressions[i]).getKind().equals(">>>="))) {
          foundAssignment = true;
          break;
        }
      }
      if (!(lastPiece instanceof MethodInvocationExpression) &&
          !(lastPiece instanceof AllocationExpression) &&
          !(piecesWithNoOtherExpressions[0] instanceof Operator && (((Operator)piecesWithNoOtherExpressions[0]).getKind().equals("++") 
                                                || ((Operator)piecesWithNoOtherExpressions[0]).getKind().equals("--"))) &&
          !(lastPiece instanceof Operator && (((Operator)lastPiece).getKind().equals("++") 
                                                || ((Operator)lastPiece).getKind().equals("--"))) &&
          !foundAssignment)
      {
        _throwParseException("This is not a statement.");
      }
      else {
        //      exp = new Expression(_loc(first), (ExpressionPiece[])exprPieceList.toArray(new ExpressionPiece[0]));
        return new StatementExpression(_loc(first), exp); 
      }
    }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "<identifier> expected");
  }
}

Statement SwitchStatement() :
{
  Expression test;
  SwitchCase tempCase;
  LinkedList/*<SwitchCase>*/ caseList = new LinkedList/*<SwitchCase>*/();
  Token first = getToken(1);
}
{
  <SWITCH> (<LPAREN> | _errorChar('('))
  test = Expression(")")
  <RPAREN> (<LBRACE> | _errorChar('{'))
  (
    tempCase = SwitchCase()
    { caseList.add(tempCase); }
  )*
  (<RBRACE> | _errorChar('}'))
  {
    return new SwitchStatement(_loc(first), test, caseList.toArray(new SwitchCase[0]));
  }
}

SwitchCase SwitchCase() :
{
  BracedBody statements;
  Expression label;
  Token first = getToken(1);
}
{
  <CASE> label = Expression(":") <COLON> statements = BracedBody() // changed from BlockStatements()
  { return new LabeledCase(_loc(first), statements, label); }
|
  <_DEFAULT> <COLON> statements = BracedBody() // changed from BlockStatements()
  { return new DefaultCase(_loc(first), statements); }
}

Statement IfStatement() : 
{
  Expression testExpression;
  Statement thenStatement;
  Statement elseStatement = null;
  Token first = getToken(1);
}
{
  <IF>
  (<LPAREN> | _errorChar('('))
  testExpression = Expression(")")
  (<RPAREN> | _errorChar(')'))
  thenStatement = Statement()
  [ LOOKAHEAD(1) <ELSE> elseStatement = Statement() ]
  {
    if (elseStatement == null) {
      return new IfThenStatement(_loc(first), testExpression, thenStatement);
    }
    else {
      return new IfThenElseStatement(_loc(first), testExpression, thenStatement, elseStatement);
    }
  }  
}

WhileStatement WhileStatement() :
{
  Expression condition;
  Statement body;
  Token first = getToken(1);
}
{
  <WHILE> (<LPAREN> | _errorChar('(')) condition = Expression(")") (<RPAREN> | _errorChar(')')) body = Statement()
  { return new WhileStatement(_loc(first), condition, body); }
}

Statement DoStatement() :
{
  Expression condition;
  Statement body;
  Token first = getToken(1);
}
{
  <DO> body = Statement() (<WHILE> | _errorString("\"while\"")) (<LPAREN> | _errorChar('(')) condition = Expression(")") 
    (<RPAREN> | _errorChar(')')) (<SEMICOLON> | _errorChar(';'))
  { return new DoStatement(_loc(first), body, condition); }
}

ForStatement ForStatement() :
{  
  ForInitI init = EMPTY_FOR_INIT;
  ForConditionI condition = EMPTY_FOR_CONDITION;
  ForUpdateI update = EMPTY_FOR_UPDATE;
  Statement body; // can be a block
  Token first = getToken(1);
}
{
  <FOR> (<LPAREN> | _errorChar('(')) [ init = ForInit() ] (<SEMICOLON> | _errorChar(';'))
  [ condition = Expression(";") ] (<SEMICOLON> | _errorChar(';'))
  [ update = ForUpdate() ] (<RPAREN> | _errorChar(')'))
  body = Statement()
  { return new ForStatement(_loc(first), init, condition, update, body); }
}

ForInitI ForInit() :
{
  ForInitI init;
}
{
  (
    LOOKAHEAD( [ <FINAL> ] Type() <IDENTIFIER> )
    init = VariableDeclaration()
  |
    init = StatementExpressionList()
  )
  { return init; }
}

ForUpdateI ForUpdate() :
{
  ForUpdateI temp;
}
{
  temp = StatementExpressionList()
  { return temp; }
}

BreakStatement BreakStatement() :
{
  Token label = null;
  Token first = getToken(1);
}
{
  <BREAK> [ label = <IDENTIFIER> ] (<SEMICOLON> | _errorChar(';'))
  {
    if (label == null) {
      return new UnlabeledBreakStatement(_loc(first));
    }
    else {
      return new LabeledBreakStatement(_loc(first), label.image);
    }
  }
}

ContinueStatement ContinueStatement() :
{
  Token label = null;
  Token first = getToken(1);
}
{
  <CONTINUE> [ label = <IDENTIFIER> ] (<SEMICOLON> | _errorChar(';'))
  {
    if (label == null) {
      return new UnlabeledContinueStatement(_loc(first));
    }
    else {
      return new LabeledContinueStatement(_loc(first), label.image);
    }
  }
}

ReturnStatement ReturnStatement() :
{
  Expression value = null;
  Token first = getToken(1);
}
{
  <RETURN> [ value = Expression(";") ] (<SEMICOLON> | _errorChar(';'))
  {
    if (value == null) {
      return new VoidReturnStatement(_loc(first));
    }
    else {
      return new ValueReturnStatement(_loc(first), value);
    }
  }
}

ThrowStatement ThrowStatement() :
{
  Expression exp;
  Token first = getToken(1);
}
{
  <THROW> exp = Expression(";") (<SEMICOLON> | _errorChar(';'))
  { return new ThrowStatement(_loc(first), exp); }
}

SynchronizedStatement SynchronizedStatement() :
{
  Expression exp;
  Block block;
  Token first = getToken(1);
}
{
  <SYNCHRONIZED> (<LPAREN> | _errorChar('(')) exp = Expression(")") <RPAREN> block = Block()
  { return new SynchronizedStatement(_loc(first), exp, block); }
}

TryCatchStatement TryStatement() :
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
{
  Block tryBlock;
  LinkedList/*<CatchBlock>*/ catchList = new LinkedList/*<CatchBlock>*/();
  FormalParameter catchParam;
  Block tempCatchBlock;
  Block finallyBlock = null;
  Token first = getToken(1);
}
{
  <TRY> tryBlock = Block()
  (
    <CATCH> (<LPAREN> | _errorChar('(')) catchParam = FormalParameter() (<RPAREN> | _errorChar(')'))
    tempCatchBlock = Block()
    { catchList.add(new CatchBlock(_loc(first), catchParam, tempCatchBlock)); }
  )*
  [ <FINALLY> finallyBlock = Block() ]
  {
    CatchBlock[] catches = catchList.toArray(new CatchBlock[0]);
    if (finallyBlock == null) {
      return new NormalTryCatchStatement(_loc(first), tryBlock, catches);
    }
    else {
      return new TryCatchFinallyStatement(_loc(first), tryBlock, catches, finallyBlock);
    }
  }
}

// A statement expression is an expression followed by a semicolon.
StatementExpressionList StatementExpressionList() :
{
  LinkedList/*<Expression>*/ expressions = new LinkedList/*<Expression>*/();
  Expression exp;
  Token first = getToken(1);
}
{
  /** The semicolon terminates each statement expression in a ForInit */
  exp = Expression(",);")
  { expressions.addLast(exp); }
  (
   <COMMA>
   exp = Expression(",);")
   { expressions.addLast(exp); }
   )*
   {
     return new StatementExpressionList(_loc(first),
                                        expressions.toArray(new Expression[0]));
   }  
}

void PrecedingUnaryOpLookahead() :
{
}
{
  (<INCR> | <DECR> | <TILDE> | <BANG> | <PLUS> | <MINUS>)
}
  
Expression Expression(String terminator) :
{
  LinkedList/*<ExpressionPiece>*/ exprPieceList = new LinkedList/*<ExpressionPiece>*/();
  ExpressionPiece exprPiece;
  Expression expr;
  Token nextToken;
  Token first = getToken(1);
}
{
  try {
    (LOOKAHEAD(2)
     exprPiece = NonOtherExpression(terminator)
       /** CastExpression can only appear at the beginning of an expression */
       | LOOKAHEAD(CastLookahead())
       exprPiece = CastExpression(terminator)
       | LOOKAHEAD(DotClassLookahead())
       exprPiece = DotClass()
//       | LOOKAHEAD(PrecedingUnaryOpLookahead())
//       exprPiece = Operator()
//       expr = Expression(terminator) 
//       { exprPieceList.addLast(exprPiece);
//      ExpressionPiece[] epArray = expr.getPieces();
//      for (int i = 0; i < epArray.length; i++) {
//        exprPieceList.addLast(epArray[i]);
//      }
//    }
       | exprPiece = OtherExpression(terminator)
       ) { exprPieceList.addLast(exprPiece); }
      (
    LOOKAHEAD(2) // used to lookahead to avoid <DOT> <SUPER> (qualified explicit constructor)
       (
        ( 
         <DOT>
         (
          LOOKAHEAD(2)
            exprPiece = NonOtherExpression(terminator)
            | exprPiece = Word()
            | exprPiece = ThisLiteral()
//            | exprPiece = ClassLiteral()
            ) { exprPieceList.addLast(exprPiece); }
      )
          |
        (
         /* This part checks for a MethodInvocation, AllocationExpression, 
          * CastExpression, DotClass, or OtherExpression preceded by an operator.  It's invalid if there is
          * no operator before anything except an operator or bracketed since it would be something like "a new foo()".
          */
          LOOKAHEAD(<NEW> | <IDENTIFIER> Arguments() | CastLookahead() | DotClassLookahead() | OtherExpression())
         (
          LOOKAHEAD(2)
          exprPiece = NonOtherExpression(terminator)
            | LOOKAHEAD(CastLookahead())
            exprPiece = CastExpression(terminator)
            | LOOKAHEAD(DotClassLookahead())
            exprPiece = DotClass()
            | LOOKAHEAD(OtherExpression())
            exprPiece = OtherExpression(terminator)
            )
           {
        ExpressionPiece ep = exprPieceList.getLast();
        // If the thing we just read in is not an operator or bracketed(array access), then the previous token must have been an operator.
        //System.out.println("previous = " + ep + " current = " + exprPiece);
        if (!(exprPiece instanceof OtherExpression && (((OtherExpression)exprPiece).getExprPiece() instanceof Operator
                                                         || ((OtherExpression)exprPiece).getExprPiece() instanceof Bracketed))) {
          if (ep instanceof OtherExpression) {
            if (!(((OtherExpression)ep).getExprPiece() instanceof Operator)) {
              //            System.out.println(exprPieceList.getLast() + " " + exprPieceList.getLast().getClass());
              _throwParseException("There must be a keyword or operator before this expression.");
            }
          }
          else {
            _throwParseException("There must be a keyword or operator before this expression.");
          }
        }
      }
         |
         //       LOOKAHEAD(<INSTANCEOF>)
         exprPiece = InstanceOfExpression(terminator)
           |//         | LOOKAHEAD(<HOOK>)
           exprPiece = ConditionalExpression(terminator) 
//           |
//         exprPiece = OtherExpression(terminator)
           ) { 
           exprPieceList.addLast(exprPiece); }
        )
         {
          nextToken = getToken(1);
          if (terminator.indexOf(nextToken.image) != -1) {
            return new Expression(_loc(first), exprPieceList.toArray(new ExpressionPiece[0]));
//            return new OtherExpression(_loc(first), (JExpression[])expressions.toArray(new JExpression[0]));
          }
        }
        
       )*
    { return new Expression(_loc(first), exprPieceList.toArray(new ExpressionPiece[0]));}
  }
  catch (ParseException pe) {
    if (terminator.indexOf(first.image) != -1) { 
      _throwParseException("Missing an expression here");
    }
    StringBuffer message = new StringBuffer();
    for (int i = 0; i < terminator.length(); i++) {
      if (i > 0) {
        if (i == (terminator.length() - 1)) {
          message.append(" or ");
        }
        else {
          message.append(", ");
        }
      }
      message.append(terminator.charAt(i));
    }
    _throwParseException(pe, "This is an invalid expression: " + message.toString() + " expected");
  }
}

/** A NonOtherExpression is an expression that 
 * needs to be parsed to handle possible generic type parameters (so
 * we can match angle brackets)
 * @param terminator A String containing characters that mark the end
 * of this expression.
 */
ExpressionPiece NonOtherExpression(String terminator) :
{
  ExpressionPiece exprPiece;
}
{
  (
   exprPiece = MethodInvocationExpression()
     | exprPiece = AllocationExpression()
     //    exp = PrimaryPrefix(terminator)
//    (
//      LOOKAHEAD(2)
//      exp = PrimarySuffix(exp, terminator) |
//     exp = OtherExpression(exp, terminator)
//    )*
  )
  { return exprPiece; }
}

//Expression PrimaryPrefix(String terminator) :
//{
//  Expression exp;
//  Word w;
//  Token first = getToken(1);
//}
//{
//  try {
//    ( 
////     LOOKAHEAD(CompoundWord() Arguments())
////       ret = MethodInvocationExpression(ret, terminator)
////       | LOOKAHEAD([ CompoundWord() <DOT> ] <NEW>)
//       exp = AllocationExpression(NO_ALLOCATION_QUALIFIER)
//       | LOOKAHEAD(<LPAREN> Type())
//       exp = CastExpression(terminator)
////       | <LPAREN> Expression(terminator) <RPAREN>
//       | exp = Parenthesized()
//       | <THIS> { exp = new ThisLiteral(_loc(first)); }
//       | <SUPER> <DOT> w = Word()
//       { exp = new SuperMemberAccess(_loc(first), w); }
//     | LOOKAHEAD(DotClass())
//       exp = DotClass()
//       | //LOOKAHEAD(Word() <DOT>)
//     exp = Word()
//       )
//     { return exp; }
//  }
//  catch (ParseException pe) {
//    _throwParseException(pe, "This cannot appear at the start of an expression!");
//  }
//}
//
//Expression PrimarySuffix(Expression prefix, String terminator) :
//{
//  Expression temp;
//  Word word;
//  Expression[] arguments;
//}
//{
//  try {
//    (
//     LOOKAHEAD(2)
//     <DOT> <THIS> { return new DotThis(_loc(prefix), prefix); }
//     |
//     LOOKAHEAD(2)
//       // weird qualified allocation expression!
//       // prefix is the qualifier
//       <DOT> temp = AllocationExpression(prefix)
//       { return temp; }
//     |
//     <LBRACKET> temp = Expression("]") <RBRACKET>
//     { return new ArrayAccess(_loc(prefix), prefix, temp); }
//     |
//     <DOT> word = Word()
//     { return new MemberAccess(_loc(prefix), prefix, word); }
//     |
//     arguments = Arguments()
//       { return new MethodInvocationExpression(_loc(prefix), prefix, arguments); }
//     )
//  }
//  catch (ParseException pe) {
//    _throwParseException(pe, "This cannot appear in the suffix of the expression!");
//  }
//      | 
//      LOOKAHEAD(CompoundWord() Arguments())
//        ret = MethodInvocationExpression(ret, terminator)
//        | LOOKAHEAD([ CompoundWord() <DOT> ] <NEW>)
//        ret = AllocationExpression(ret)
//        | FieldAccess()
//        )
//       |
//     ret = ArrayAccessExpression(ret)
//       )
//      { return ret; }
//}

ConditionalExpression ConditionalExpression(String terminator) :
{
  Expression conseq;
  Expression alt;
  Token first = getToken(1);
}
{
  try {
    <HOOK>
      conseq = Expression(":") <COLON>
      alt = Expression(terminator)
    { return new ConditionalExpression(_loc(first), conseq, alt); }  
  }
  catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in a condtional expression!");
  }
}
  
/** Differentiates between array allocations and anonymous inner class definitions
 * @param qualifier the CompoundWord before the new. (e.g. a.new Foo())
 */
AllocationExpression AllocationExpression() :
{
  PrimitiveType tempPrimitive;
  ReferenceType tempReference;
  AllocationExpression temp;
  BracedBody body = null;
  Expression[] arguments;
  Token first = getToken(1);
}
{
  try {
//   [ LOOKAHEAD(Word() <DOT>) 
//      qualifier = CompoundWord() <DOT> ]
  (
   LOOKAHEAD(2)
     <NEW>
   tempPrimitive = PrimitiveType()
     temp = ArrayAllocationExpression(tempPrimitive)
     |
   <NEW>
   tempReference = ClassOrInterfaceType()
     (
      temp = ArrayAllocationExpression(tempReference)
        |
      arguments = Arguments()
       [ LOOKAHEAD(<LBRACE>) <LBRACE> body = BracedBody() (<RBRACE> | _errorChar('}'))]
        {
    if (body == null) {
      temp = new InstanceAllocationExpression(_loc(first),
                                              tempReference, 
                                              arguments);
    }
    else {
      temp = new AnonymousInnerClassExpression(_loc(first),
                                               tempReference,
                                               arguments,
                                               body);
    }
  }
      
  )
     )
  { return temp; }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in an allocation expression!");
  }
}

// an array allocation either has at least one dimension expression
// or it has an initializer. can't have both.
ArrayAllocationExpression ArrayAllocationExpression(Type elementType) :
{
  LinkedList/*<Expression>*/ dimensions = new LinkedList/*<Expression>*/();
  ArrayType arrayType = null;
  Expression exp;
  ArrayInitializer initializer;
  Token first = getToken(1);
}
{
  (
    LOOKAHEAD(2)
    (
      (
        LOOKAHEAD(2)
        <LBRACKET>
        exp = Expression("]")
         <RBRACKET>
        {
          if (arrayType == null) {
            arrayType = new ArrayType(_loc(elementType), elementType.getName() + "[]", elementType);
          }
          else {
            arrayType = new ArrayType(_loc(arrayType), arrayType.getName() + "[]", arrayType);
          }

          dimensions.add(exp);
        }
      )+
      (
        LOOKAHEAD(2) <LBRACKET> <RBRACKET>
        { arrayType = new ArrayType(_loc(arrayType), arrayType.getName() + "[]", arrayType); }
      )* {
        return new DimensionalArrayAllocationExpression(_loc(first),
                                                        arrayType,
                                                        dimensions.toArray(new Expression[0]));
      }
    )
  |
    (
      (
        LOOKAHEAD(2) <LBRACKET> <RBRACKET>
        {
          if (arrayType == null) {
            arrayType = new ArrayType(_loc(elementType), elementType.getName() + "[]", elementType);
          }
          else {
            arrayType = new ArrayType(_loc(arrayType), arrayType.getName() + "[]", arrayType);
          }
        }
      )+
      initializer = ArrayInitializer()
    )
  {
    return new InitializedArrayAllocationExpression(_loc(first),
                                                    arrayType,
                                                    initializer);
      }
  )
}

/**
 * Recognizes: Type (identifier [, initializer ] )+.
 */
LinkedList/*<VariableDeclarator>*/ VariableDeclaratorList() :
{
  LinkedList/*<VariableDeclarator>*/ list = new LinkedList/*<VariableDeclarator>*/();

  Type originalType;
  VariableDeclarator current;
}
{
  try {
    originalType = Type()
      current = VariableDeclarator(originalType)
    {
      list.add(current);
    }
    
    (
     <COMMA>
     current = VariableDeclarator(originalType)
       {
      list.add(current);
    }
    )*
    { return list; }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in a variable declarator!");
  }
}

/**
 * Recognizes an identifier with any number of possible brackets.
 * Figures out the real type by dealing with the fact
 * that [] can be either after type or after identifier!
 * Very strange syntax indeed.
 * TODO: Make sure FormalParameter (or anything else that can't have
 * initialized variable declarators to check for this).
 *
 * @param givenType The type that was recognized before this identifier
 * @return The pair of type and identifier. The type encompasses
 *         all levels of array []s needed (from both after the type and
 *         after the identifier).
 */
VariableDeclarator VariableDeclarator(Type givenType) :
{
//  VariableDeclarator decl = new VariableDeclarator();
  Type type = givenType;
  Word identifier;
  VariableInitializerI initializer = null;
}
{
  identifier = Word()

  ( <LBRACKET> <RBRACKET> {
      type = new ArrayType(_loc(identifier), type.getName() + "[]", type);
    }
  )*
    [ <ASSIGN> initializer = VariableInitializer() ]

  {
    if (initializer == null) {
      return new UninitializedVariableDeclarator(_loc(identifier), 
                                                 type, 
                                                 identifier);
    }
    else {
      return new InitializedVariableDeclarator(_loc(identifier), 
                                               type,                                                
                                               identifier, 
                                               initializer);
    }    
  }
}

VariableInitializerI VariableInitializer() :
{
  VariableInitializerI init;
}
{
  try {
    (
     LOOKAHEAD(<LBRACE>)
       init = ArrayInitializer()
       |
     init = Expression(",};")
       )  
    {
      return init;
    }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "This is an illegal variable initializer!");
  }
}

ArrayInitializer ArrayInitializer() :
{
  LinkedList/*<VariableInitializerI>*/ items = new LinkedList/*<VariableInitializerI>*/();
  VariableInitializerI varInit;
  Token first = getToken(1);
}
{
  try {
    <LBRACE>
      [
       varInit = VariableInitializer() { items.add(varInit); }
       (
        LOOKAHEAD(2) <COMMA>
        varInit = VariableInitializer() { items.add(varInit); }
       )*
       ]
         [ <COMMA> ] (<RBRACE> | _errorChar('}'))
       {
         return new ArrayInitializer(_loc(first),
                                     items.toArray(new VariableInitializerI[0]));
       }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "This is an illegal array initializer!");
  }
}

Expression[] Arguments() :
{
  Expression[] args = new Expression[0];
}
{
  <LPAREN> [ args = ArgumentList() ] <RPAREN>
  { return args; }
}

Expression[] ArgumentList() :
{
  LinkedList/*<Expression>*/ list = new LinkedList/*<Expression>*/();
  Expression temp;
}
{
  try {
    temp = Expression(",)") { list.add(temp); }
    (
     <COMMA>
     temp = Expression(",)") {list.add(temp); }
    )*
    { return list.toArray(new Expression[0]); }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in an argument list!");
  }
}
  
MethodInvocationExpression MethodInvocationExpression() :
{
  Word left;
  Expression[] arguments;
  Token first = getToken(1);
}
{
  try {
    left = Word()
      arguments = Arguments()
    {
      return new MethodInvocationExpression(_loc(first), 
                                            left, 
                                            arguments);
    }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in a method invocation expression!");
  }
}



// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.  We need this check to disambiguate from an expression like (x) + 3.
void CastLookahead() :
{}
{
  LOOKAHEAD(2)
  <LPAREN> PrimitiveType() (<LBRACKET> <RBRACKET>)* <RPAREN>
|
  LOOKAHEAD(<LPAREN> CompoundWord() <LBRACKET>)
  <LPAREN> CompoundWord() <LBRACKET> <RBRACKET>
|
  <LPAREN> CompoundWord() <RPAREN> ( <TILDE> | <BANG> | <LPAREN> | <IDENTIFIER> | <THIS> | <SUPER> | <NEW> | Literal() )
}

CastExpression CastExpression(String terminator) :
{
  Expression value;
  Type type;
  Token first = getToken(1);
}
{
  (
    <LPAREN> type = Type() <RPAREN> value = Expression(terminator)
  )
  { return new CastExpression(_loc(first), type, value); }
}

InstanceOfExpression InstanceOfExpression(String terminator) :
{
  Type type;
  Token first = getToken(1);
}
{
  try {
    <INSTANCEOF>
      type = Type()
    { return new InstanceOfExpression(_loc(first), type); }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "This cannot appear in an instanceof expression!");
  }
}

void DotClassLookahead() :
{}
{
  (<VOID> | 
   (PrimitiveType() | (LOOKAHEAD(2) ClassOrInterfaceType() | TypeVariable()))
  (<LBRACKET> <RBRACKET>)*)
  <DOT> <CLASS>
}

DotClass DotClass() :
{
  ReturnTypeI type;
  Token first = getToken(1);
}
{
  type = ReturnType()
  <DOT> <CLASS>
  { return new DotClass(_loc(first), type); }
}

OtherExpression OtherExpression(String terminator) :
{
  Token nextToken;
  ExpressionPiece expr;
  Token first = getToken(1);
}
{
  try {
     (
      // Perhaps we should make each of these implement OtherExpressionI?
//      LOOKAHEAD(NonOtherExpression(terminator))
//        expr = NonOtherExpression(terminator) |
//      expr = Braced() |
      expr = Bracketed() | // for array allocation
      expr = Parenthesized() |  // for arithmetic or grouping of expressions
      expr = Operator() |
      expr = Literal() |
      expr = ThisLiteral() |
      expr = SuperLiteral() |
//      LOOKAHEAD(Word() <DOT>)
//      expr = CompoundWord() |
      expr = Word()
        )
       {
      return new OtherExpression(_loc(first), expr);
    }
  }
  catch (ParseException pe) {
    _throwParseException(pe, "This is an illegal expression!");
  }
}