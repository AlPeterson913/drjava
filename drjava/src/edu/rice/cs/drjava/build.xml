<!--
  $Header$
-->
<project name="drjava" default="test">
  <!-- This makes the javac task use the GJ compiler. -->
  <property name="build.compiler"
            value="edu.rice.cs.anttools.GJv6CompilerAdapter" />

  <property name="jsr14_path" value="/home/javaplt/packages/jsr14_adding_generics-1_0-ea" />

  <!-- srcroot is the base directory of the source, 4 packages back -->
  <property name="srcroot" value="../../../.." />
  <!-- built is where the compiled classes go -->
  <property name="built" value="${srcroot}/../built/" />
  <!-- projpath is the path from srcroot to the root directory of this project
  -->
  <property name="projpath" value="edu/rice/cs/${ant.project.name}" />

  <!-- What file will have $Name$ expanded in it properly? -->
  <property name="file_with_build_name" value="DrJava.java" />

  <property name="jarfile" value="${srcroot}/../drjava2.jar" />
  <property name="manifest" value="manifest" />
  <property name="cvsroot" value="/home/javaplt/.cvsroot" />

  <!-- Init target. All others depend on it. Initialize the directory. -->
  <target name="init">
    <tstamp /> <!-- Ant requires us to make time stamp -->
    <mkdir dir="${built}" /> <!-- Make the built directory -->
  </target>

  <!-- Reconcile source with CVS archive -->
  <target name="update" depends="init">
    <cvs command="update -d" cvsRoot="${cvsroot}" />
  </target>

  <!-- Commit source to CVS archive
       Before doing do, we update our copy with the CVS copy. This ensures that
       if there were any clashes, we have to resolve them now. Then we
       recompile (from scratch) and retest. If this all succeeds, we can commit.

       After committing, we tag the build we just made with the tag
       projectname-date-time.
  -->
  <target name="commit" depends="clean, update, test">
    <cvs command="commit" cvsRoot="${cvsroot}" />
    <tstamp /> <!-- get new time stamp to use for CVS tag -->
    <property name="version-tag"
              value="${ant.project.name}-${DSTAMP}-${TSTAMP}" />
    <cvs command="tag ${version-tag}" cvsRoot="${cvsroot}" quiet="true" />

    <!-- Delete MainFrame.java and re-update to set $Name$ tags. -->
    <delete file="${file_with_build_name}" />
    <cvs command="update -r${version-tag} ${file_with_build_name}"
         cvsRoot="${cvsroot}" quiet="true" />

    <!-- we need to "unstick" the tag we checked it out with. otherwise
         we can't check this file back in! -->
    <cvs command="update -A ${file_with_build_name}"
         cvsRoot="${cvsroot}" quiet="true" />
    <echo message="New version ${version-tag} committed to CVS." />
  </target>

  <!-- Compile. We have to start at srcroot and then selectively include
       just this project in order for it to realize what files have already
       been compiled (preventing needless recompilation)
  -->
  <target name="compile-gj" depends="init">
    <javac srcdir="${srcroot}"
           includes="${projpath}/**/*java"
           destdir="${built}" 
           debug="on"
           optimize="off" />
  </target>

  <!-- Compile using JSR14 compiler. Hack. Bad. -->
  <target name="compile" depends="init">
    <echo message="Compiling with JSR14 compiler ..." />
    <execon executable="javac"
            failonerror="yes"
            parallel="yes"
            type="file">
      <arg value="-sourcepath" />
      <arg value="${srcroot}" />

      <!-- Tell the compiler to generate bytecode with version number
           that will run on JDK 1.2! -->
      <arg value="-target" />
      <arg value="1.2" />

      <arg value="-g" />
      <arg value="-d" />
      <arg value="${built}" />
      <arg value="-J-Xbootclasspath/p:${jsr14_path}/javac.jar" />
      <arg value="-bootclasspath" />
      <arg path="${jsr14_path}/collect.jar:${java.home}/lib/rt.jar" />
      <fileset dir="${srcroot}">
        <include name="${projpath}/**/*.java" />
      </fileset>
    </execon>
  </target>

  <!-- Unit test -->
  <target name="test" depends="compile">
    <junit printsummary="yes" haltonerror="yes" haltonfailure="yes" fork="no">
      <!-- propogate the same classpath. not sure why it doesn't
           happen by default!
      -->
      <classpath path="${java.class.path}" />

      <!-- This makes JUnit display info about each test to console -->
      <formatter type="plain" usefile="no" />

      <!-- This makes JUnit run all test classes. It figures out which ones
           automatically, without needing AllTests classes.
      -->
      <batchtest>
        <!-- The root of the fileset must be where edu/ is. -->
        <fileset dir="${srcroot}">
          <!-- Include only from projpath to only get classes in this project!
          -->
          <include name="${projpath}/**/*Test.java" />
          <exclude name="**/AllTests.java" />
          <exclude name="**/Test.java" />
        </fileset>
      </batchtest>
    </junit>
  </target>

  <!-- Makes a jar for distribution. No tests are included. -->
  <target name="jar" depends="test">
    <jar jarfile="${jarfile}"
         basedir="${built}"
         excludes="**/*Test.class"
         manifest="${manifest}" />
  </target>

  <!-- Run the program! -->
  <target name="run" depends="compile">
    <java classpath="${built}:${java.class.path}"
          fork="true"
          classname="edu.rice.cs.drjava.DrJava" />
  </target>

  <!-- Delete all generated files (only for this project!) -->
  <target name="clean">
    <delete dir="${built}/${projpath}" />
    <delete file="${jarfile}" />
  </target>
</project>

